<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一直卡在 0%[正在等待报头]</title>
    <url>/2020/03/14/%E4%B8%80%E7%9B%B4%E5%8D%A1%E5%9C%A8%200%25%5B%E6%AD%A3%E5%9C%A8%E7%AD%89%E5%BE%85%E6%8A%A5%E5%A4%B4%5D/</url>
    <content><![CDATA[<p>sudo rm -rf /var/lib/apt/lists/*  删除了该目录</p>
]]></content>
  </entry>
  <entry>
    <title>第五篇</title>
    <url>/2020/03/02/JMM/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁CAS</title>
    <url>/2019/09/22/%E4%B9%90%E8%A7%82%E9%94%81CAS/</url>
    <content><![CDATA[<h3 id="乐观锁CAS"><a href="#乐观锁CAS" class="headerlink" title="乐观锁CAS"></a>乐观锁CAS</h3><p>下面的程序中我们可能会使用synchronized关键字来保证得到的num是正确的。但是这样会让没有得到锁的线程进入blocked状态，当拿到锁之后恢复到runnable状态，这个过程设计操作系统的用户模式和内核模式的切换。<br><br>Java从jdk1.5开始提供了<strong>java.util.concurrent.atomic</strong>包，这个包下有很多的原子类操作。例如常用的原子更新基本类型的<strong>AtomicBoolean，AtomicInteger，AtomicLong</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.jiasheng.CAS;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class TestCAS &#123;</span><br><span class="line">    private static AtomicInteger num &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public static void add() &#123;</span><br><span class="line">        &#x2F;&#x2F;num++；不是原子性擦操作，加上synchronized可以解决，但是严重降低了性能</span><br><span class="line">        num.incrementAndGet(); &#x2F;&#x2F; AtomicInteger +1方法，底层是CAS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 5000; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(Thread.activeCount() &gt; 2)&#123; &#x2F;&#x2F;main gc</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原子操作类的底层利用的正是CAS机制，全称即Compare and Swap。<br><br><br>先看一下compareAndSet源码：<br><br>调用这个方法传递的参数expect和update，expect期望值就是我们期望内存中某个变量的旧值是什么，update新值就是我们希望修改成什么值。valueOffset据说是一个偏移地址？不过不重要，这个不是重点，只要知道它是一个volatile修饰的变量即可。<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compareAndSet调用的compareAndSwapInt方法使用C++实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure>

<p>我们现在来看一下上面程序中++操作的incrementAndGet的源码：<br><br><strong>AtomicInteger.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Atomically increments by one the current value.</span><br><span class="line"> *</span><br><span class="line"> * @return the updated value</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delta就是需要自增的值，incrementAndGet传进来的是1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAdd(int delta) &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的unsafe类的getAndAddInt方法，继续查看这个方法的源码：<br><br><strong>unsafe.java</strong><br><br>这里var1是实例，var2就是偏移地址，var3就是上面的delta，这里是1<br><br>while循环中第三个参数var5就是expect值，var5+var4就是update值，var5这个值是根据this.getIntVolatile(var1, var2);计算出来的，就是读取到这个时刻内存这边旧值的最新值，因为有可能A线程准备替换之前，已经被B线程更新了，即两个线程都执行到了getIntVolatile方法。所以需要把var5更新到当前时刻的最新值。<br><br>while循坏就是判断就是except（也即var5）是否是线程A一开始希望的那个值，要确保是当前状态的最新值。</p>
<p><br>这里的while循环也叫作CAS自旋。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getAndAddInt方法里面调用的下面这两个方法都是native修饰的方法，即底层是C++实现的。效率会比自增操作高很多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int getIntVolatile(Object var1, long var2);</span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure>

<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ol>
<li>在高并发的场景下，如果多个线程都去反复尝试更新某一个相同的变量，但期望值却一直被改变了，就会造成循环次数很多，造成CPU很大的开销。</li>
<li>可能造成ABA问题。如果一个变量的值原来是A，先修改成B，然后又修改回A，使用CAS机制的话，无法分辨当前的except值是否已经发生过变化。</li>
</ol>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu环境下执行sudo apt-get update出现无法获得锁 /var/lib/apt/lists/lock - open的问题解决方法</title>
    <url>/2019/09/15/%E6%89%A7%E8%A1%8Csudo%20apt-get%20update%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/03/14/8QXxbt.png" alt="avator"></p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>执行ps -e | grep apt找到占用系统源更新时的系统锁的进程<br><img src="https://s1.ax1x.com/2020/03/14/8QjJq1.png" alt="avator"></li>
</ol>
<p>2.结束占用它的线程，输入命令sudo kill 进程ID号<br>再次执行 ps -e | grep apt，发现已经没有占用apt -get的进程了<br><img src="https://s1.ax1x.com/2020/03/14/8QjtVx.png" alt="avator"></p>
<ol start="3">
<li>输入sudo apt-get update，成功！</li>
</ol>
]]></content>
      <tags>
        <tag>问题解决</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出ABA问题</title>
    <url>/2019/09/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAABA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="什么是ABA问题？"><a href="#什么是ABA问题？" class="headerlink" title="什么是ABA问题？"></a>什么是ABA问题？</h3><p>如果一个变量的值原来是A，先修改成B，然后又修改回A，使用<strong>CAS机制</strong>的话，无法分辨当前的except值是否已经发生过变化。（可先理解一下什么是CAS机制）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.CAS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建两个线程</span></span><br><span class="line"><span class="comment"> * A线程需要把2改成3</span></span><br><span class="line"><span class="comment"> * B线程先把2改成6，再把6改回2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestABA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 开启，num = "</span> + atomicInteger);</span><br><span class="line">            <span class="comment">//A线程休眠2s，让出CPU给其他线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS操作一波</span></span><br><span class="line">            <span class="keyword">boolean</span> except = atomicInteger.compareAndSet(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">"cas is success ? "</span> + except);</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//保证main线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicInteger.incrementAndGet();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"increment, num = "</span> + atomicInteger);</span><br><span class="line"></span><br><span class="line">            atomicInteger.decrementAndGet();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"decrement, num = "</span> + atomicInteger);</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/22/8oQT9P.png" alt="avator"></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以给竞争资源加锁，但是这样性能会降低。所以，我们使用<strong>AtomicStampedReference</strong>类。这是一个原子更新带有<strong>版本号</strong>的引用类型，每次操作都会更改版本号。</p>
<p><strong>构造函数</strong><br>initialRef初始值，initialStamp初始版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public AtomicStampedReference(V initialRef, int initialStamp) &#123;</span><br><span class="line">    pair &#x3D; Pair.of(initialRef, initialStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getReference方法</strong><br><br>作用：返回当前版本号下的变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns the current value of the reference.</span><br><span class="line"> *</span><br><span class="line"> * @return the current value of the reference</span><br><span class="line"> *&#x2F;</span><br><span class="line">public V getReference() &#123;</span><br><span class="line">    return pair.reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getStamp方法</strong><br><br>作用：返回变量当前值的版本号，即获取最新的版本号是多少</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns the current value of the stamp.</span><br><span class="line"> *</span><br><span class="line"> * @return the current value of the stamp</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int getStamp() &#123;</span><br><span class="line">    return pair.stamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>compareAndSet方法</strong><br><br>expectedReference：旧的值<br><br>newReference：新的值，就是我们想要修改为什么值<br><br>expectedStamp：旧的版本号<br><br>newStamp：新的版本号，一般是expectedStamp+1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   newReference,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current &#x3D; pair;</span><br><span class="line">    return</span><br><span class="line">        expectedReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">        expectedStamp &#x3D;&#x3D; current.stamp &amp;&amp;</span><br><span class="line">        ((newReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">          newStamp &#x3D;&#x3D; current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改上述存在ABA问题的程序"><a href="#修改上述存在ABA问题的程序" class="headerlink" title="修改上述存在ABA问题的程序"></a>修改上述存在ABA问题的程序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.CAS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolveABA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 开启，num = "</span> + stampedReference.getReference());</span><br><span class="line">            <span class="comment">//当前标识</span></span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            <span class="comment">//A线程休眠2s，让出CPU给其他线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS操作一波</span></span><br><span class="line">            <span class="keyword">boolean</span> except = stampedReference.compareAndSet(<span class="number">2</span>, <span class="number">3</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"cas is success ? "</span> + except);</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//保证main线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">2</span>, <span class="number">6</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"increment, num = "</span> + stampedReference.getReference());</span><br><span class="line"></span><br><span class="line">            stampedReference.compareAndSet(<span class="number">6</span>, <span class="number">2</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"decrement, num = "</span> + stampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong><br><img src="https://s1.ax1x.com/2020/03/22/8oQ4AA.png" alt="avator"></p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis快速入门</title>
    <url>/2019/08/12/Mybatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><ul>
<li>列表1</li>
<li>列表2<br>  快速入门系列</li>
</ul>
<p>1、简介</p>
<p>1.1、什么是MyBatis<br>简介<br>什么是 MyBatis？<br>MyBatis 是一款优秀的持久层框架<br>它支持定制化 SQL、存储过程以及高级映射。<br>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。<br>如何获得MyBatis？<br>Maven仓库</p>
]]></content>
      <tags>
        <tag>框架</tag>
        <tag>Mybatis</tag>
        <tag>Java</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>算法2</title>
    <url>/2019/08/02/%E7%AE%97%E6%B3%952/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第二篇</title>
    <url>/2019/08/02/%E4%BA%94%E6%AE%B5%E7%A8%8B%E5%BA%8F%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="五段程序带你深刻理解单例模式"><a href="#五段程序带你深刻理解单例模式" class="headerlink" title="五段程序带你深刻理解单例模式"></a>五段程序带你深刻理解单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式就是让一个类只能构建一个对象的设计模式</span></span><br><span class="line"><span class="comment"> * 此程序主要用于演示懒汉式和饿汉式</span></span><br><span class="line"><span class="comment"> *      饿汉式：在构造器之前就已经主动创建好实例。</span></span><br><span class="line"><span class="comment"> *      懒汉式：延迟实例化，等构造器来创建实例。</span></span><br><span class="line"><span class="comment"> * 问题：线程安全有隐患。</span></span><br><span class="line"><span class="comment"> *  如果多个线程同时调用getInstance方法，刚好都通过了判空的操作，开始执行new操作</span></span><br><span class="line"><span class="comment"> *  就会造成new重复多次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用静态变量来记录Singleton类的唯一实例</span></span><br><span class="line"><span class="comment">     * 它的初始值可以写成null，也可以写成new Singleton()</span></span><br><span class="line"><span class="comment">     * 分别可能造成懒汉式和饿汉式问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要让一个类只能构建一个对象，自然不能让它随便去做new操作，</span></span><br><span class="line"><span class="comment">     * 只有Hungry类里面才可以调用构造方法，因此Hungry的构造方法</span></span><br><span class="line"><span class="comment">     * 是私有的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂方法,获取单例对象。</span></span><br><span class="line"><span class="comment">     * 如果单例初始值instance是null，还未构建，则构建对象并返回。这种方式就是懒汉式,即延迟实例化。</span></span><br><span class="line"><span class="comment">     * 如果单例初始值一开始就通过new Singleton()主动创建，则不再需要判空操作。这种方式就是饿汉式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式</span></span><br><span class="line"><span class="comment"> * 破除第一版的线程安全问题</span></span><br><span class="line"><span class="comment"> * 方法一：在创建实例的方法加上synchronized，迫使每个线程在进入这个方法之前，要先等待其他线程</span></span><br><span class="line"><span class="comment"> *        离开该方法，也就是说，不会有两个线程同时进入这个方法，保证了线程安全。</span></span><br><span class="line"><span class="comment"> * 问题：严重影响性能！原因：只有第一次执行此方法，才真正需要同步，此后每次调用这个方法都是一种累赘</span></span><br><span class="line"><span class="comment"> * 同步一个方法可能造成程序执行效率下降100倍</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 方法二 ：DCL = double check lock  -&gt; 双重检测机制</span></span><br><span class="line"><span class="comment"> * 问题：存在指令重排问题（见下一个程序）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static synchronized Singleton2 getInstance()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一个if判断：只有当instance为null，才会向同步方法走去。如果没有这个if判断，则每次调用这个</span></span><br><span class="line"><span class="comment">     * getInstance方法，都会进入synchronized同步区，性能严重下降</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第二个if判断：假如有多个线程在同步方法入口那里，这时只能有一个线程（假设为A线程）可以进入</span></span><br><span class="line"><span class="comment">     * 同步代码块，如果是第一次进入，A线程在第二个if判断处判断为null，就会new Singleton2()。接着A线程</span></span><br><span class="line"><span class="comment">     * 退出synchronized区，此后即使有已经在synchronized处等待的线程进入同步代码块，还是会在第二个if判断处</span></span><br><span class="line"><span class="comment">     * 判定不为null，也就不会创建第二个instance。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式实现方式一：双重加锁机制+volatile</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new Singleton3()在多线程环境下存在指令重排问题</span></span><br><span class="line"><span class="comment"> * new Singleton3()会被编译器编程成如下的JVM指令：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * memory = allocate();  //1.分配对象的内存空间</span></span><br><span class="line"><span class="comment"> * ctorInstance(memory); //2.初始化对象</span></span><br><span class="line"><span class="comment"> * instance = memory;    //3.设置instance指向刚才分配的内存空间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这些指令顺序并不是一成不变的，有可能经过JVM和CPU的优化，指令重排为1 3 2</span></span><br><span class="line"><span class="comment"> * 当A线程执行完指令1,3之后，instance还未完成初始化工作，但是已经不再指向null</span></span><br><span class="line"><span class="comment"> * 此时B线程进来第一个if判断instance为null，就直接return instance;了，这样子</span></span><br><span class="line"><span class="comment"> * 返回的instance是空的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解决：使用volatile禁止指令重排</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 存在问题：可以通过反射new多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式实现方式二：静态内部类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 存在问题：可以通过反射new多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类，外部无法访问，只有当调用Singleton4.getInstance()方法时，才能</span></span><br><span class="line"><span class="comment">     * 得到单例对象。</span></span><br><span class="line"><span class="comment">     * 【注意】单例对象instance初始化的时机并不是在单例类Singleton4被加载的时候，</span></span><br><span class="line"><span class="comment">     * 而是在调用getInstance()方法，使得静态内部类LazyHolder被加载的时候。</span></span><br><span class="line"><span class="comment">     * 因此，这种实现方式是利用ClassLoader的加载机制来实现懒加载的，并保证构建单例的线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton4 instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> LazyHolder.instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用反射破坏单例的演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Constructor con = Singleton4<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;<span class="comment">//获取构造器</span></span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置私有为可访问</span></span><br><span class="line">        Singleton4 instance1 = (Singleton4) con.newInstance();</span><br><span class="line">        Singleton4 instance2 = (Singleton4) con.newInstance();</span><br><span class="line">        System.out.println(instance1.equals(instance2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式实现方式三：枚举</span></span><br><span class="line"><span class="comment"> * 成功解决反射破坏性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton5 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试反射是否可以破坏单例模式</span></span><br><span class="line"><span class="comment">//java.lang.NoSuchMethodException提示利用反射new示例不成功</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Constructor con = Singleton5<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;<span class="comment">//获取构造器</span></span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置私有为可访问</span></span><br><span class="line">        Singleton5 instance1 = (Singleton5) con.newInstance();</span><br><span class="line">        Singleton5 instance2 = (Singleton5) con.newInstance();</span><br><span class="line">        System.out.println(instance1.equals(instance2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>第六篇</title>
    <url>/2019/06/02/%E7%AC%AC%E5%85%AD%E7%AF%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法4</title>
    <url>/2019/02/12/%E7%AE%97%E6%B3%954/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法3</title>
    <url>/2019/02/05/%E7%AE%97%E6%B3%953/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法1</title>
    <url>/2019/01/09/%E7%AE%97%E6%B3%951/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>第四篇</title>
    <url>/2019/01/08/%E7%AC%AC%E5%9B%9B%E7%AF%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
