<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java内存模型JMM</title>
    <url>/2020/03/02/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</url>
    <content><![CDATA[<h2 id="原理初探"><a href="#原理初探" class="headerlink" title="原理初探"></a>原理初探</h2><p>在学习计算机组成原理的时候，我们都知道CPU的运行速度和内存不是一个级别的，CPU的速度非常快，为了缓解两者之间速度不一致的问题，我们在CPU和内存之间加了缓存。CPU执行过程中需要的数据，先从缓存中拿，如果命中了就直接拿，否则就从内存上读取，并放在缓存上面。<br>缓存分为一级缓存（L1 Cache），二级缓存（L2 Cache）和三级缓存（L3 Cache）。在多个缓存的情况下，为了保证这些缓存的数据一致，所以它们都必须遵守一些协议，常见的如MSI,MESI,MOSI等。<br>其中MESI保证每个缓存使用的共享变量的副本是一致的。核心思想：当CPU写数据时，如果发现操作的是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，则当其他CPU读取这个变量是，发现自己缓存中缓存该变量的缓存行是无效的，那么它就要从主内存中重新读取。</p>
<h2 id="JMM在同步的约定"><a href="#JMM在同步的约定" class="headerlink" title="JMM在同步的约定"></a>JMM在同步的约定</h2><ol>
<li>线程解锁前，必须把共享变量立刻刷回主存</li>
<li>线程加锁前，必须读取主存中的最新值到工作内存中</li>
<li>加锁和解锁是同一把锁</li>
</ol>
<p>【分析】下面JMM示意图中，工作内存就是每个线程自己的本地内存，每个线程优先访问工作内存，处理完之后再把工作内存向主内存进行刷新同步。</p>
<h4 id="工作内存和主内存之间有8种原子操作："><a href="#工作内存和主内存之间有8种原子操作：" class="headerlink" title="工作内存和主内存之间有8种原子操作："></a>工作内存和主内存之间有8种原子操作：</h4><p>read：在主内存中，读取变量到工作内存</p>
<p>load：在工作内存中，把read操作从主内存中读取的变量，放入到工作内存中的变量副本中</p>
<p>use：在工作内存中，把工作内存中的一个变量值传递给执行引擎，每当JVM遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p>
<p>assign：在工作内存中，把一个执行引擎接收到的值赋值给工作内存中的变量，每当JVM遇到一个给变量赋值的字节码指令时将会执行这个操作。</p>
<p>store：把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</p>
<p>write：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p>
<p>lock：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p>
<p>unlock：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
<p><img src="https://s1.ax1x.com/2020/03/23/8Tnl1U.png" alt="avator"></p>
<p>除此之外，Java内存模型还还规定了在执行上述8种基本操作时必须满足以下规则;</p>
<ul>
<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。<br>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>happens-before原则，它是判断数据是否存在竞争，线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作，准确来说是控制流程顺序，还要考虑分支和循环操作。</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作。</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li>
</ol>
<h3 id="volatile是Java虚拟提供的轻量级的同步机制"><a href="#volatile是Java虚拟提供的轻量级的同步机制" class="headerlink" title="volatile是Java虚拟提供的轻量级的同步机制"></a>volatile是Java虚拟提供的轻量级的同步机制</h3><p><strong>特性：</strong></p>
<ol>
<li>可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ol>
<h4 id="volatile读的内存语义："><a href="#volatile读的内存语义：" class="headerlink" title="volatile读的内存语义："></a>volatile读的内存语义：</h4><p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来姜葱主内存中读取共享变量。</p>
<h4 id="volatile写的内存语义："><a href="#volatile写的内存语义：" class="headerlink" title="volatile写的内存语义："></a>volatile写的内存语义：</h4><p>当写一个volatie变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>
<ol>
<li>可见性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.vl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMMDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不用volatile修饰的话，不能保证num的更新及时被其他线程发现，所以下面一个线程会一直在while中死循环</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出结果：程序正常结束！</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/23/8Tuubd.png" alt="avator"></p>
<ol start="2">
<li><p>不保证原子性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.vl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//num++；不是原子性擦操作</span></span><br><span class="line">        num.incrementAndGet(); <span class="comment">// AtomicInteger +1方法，底层是CAS</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">2</span>)&#123; <span class="comment">//main gc</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止指令重排<br>处理器在执行指令重排的时候，要考虑数据之间的依赖性。</p>
</li>
</ol>
<p>比如：定义某个变量的语句还未执行，而包含有这个变量的语句不能提前执行</p>
<p>volatile由于内存屏障，可以保证避免指令重排的现象发生。</p>
<blockquote>
<p>参考：《Java并发编程的艺术》，《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>把二叉树打印成多行</title>
    <url>/2020/03/02/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; out = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode last = pRoot;</span><br><span class="line">        list.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            pRoot = list.poll();</span><br><span class="line">            <span class="keyword">if</span>(pRoot.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(pRoot.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pRoot.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(pRoot.right);</span><br><span class="line">            &#125;</span><br><span class="line">            out.add(pRoot.val);</span><br><span class="line">            <span class="keyword">if</span>(pRoot == last)&#123;</span><br><span class="line">                last = list.peekLast();</span><br><span class="line">                res.add(out);</span><br><span class="line">                out = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分配与回收：Linux系统下利用链表实现动态内存分配</title>
    <url>/2020/02/05/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%9ALinux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>ubuntu16.04</p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>1、    静态内存与动态内存<br>按分配内存空间的方式不同，一个程序所使用的内存区域可以分为静态内存与动态内存。在程序开始运行时有系统分配的内存称为静态内存，在程序运行过程中由用户自己申请分配的内存称为动态内存。<br>静态内存的申请是由编译器来分配的。对于用户程序中的各种变量，编译器在编译源程序时处理了为各种变量分配所需内存的工作。当程序执行时，系统就为变量分配所需的内存空间，至使用该变量的函数执行完毕返回时，自动释放所占用的内存空间。使用静态内存对用户来说是很方便的。用户并不需要了解分配内存的具体细节，也不需要时刻考虑由于程序结束前未释放所占用的内存空间而带来的可用内存泄漏。同时，静态内存也是不通过指针而使用变量的唯一方法。但是，静态内存也存在一定的缺陷：首先，由于静态内存总是预先定义了存放数据的数组大小，这就有可能因为所传入的数据量大于数组容量而引发的溢出问题。或因为定义了一个大数组，而所传入的数据量远小于数组容量，而对内存空间造成浪费。<br>其次，由于在某个函数中分配的静态内存将在此函数运行结束时被系统自动释放，使用指针由子函数向主函数传递数据的设想是无法被实现的。<br>使用动态内存时，用户可以根据需要随时申请内存，使用完毕后手动将此内存区释放。在实际应用中非常方便。但动态内存的使用也存在着巨大的隐患。任何处理过大型项目的用户都知道动态内存的使用会使内存管理变得多么复杂，以及要确切地记得在使用完毕后释放所占用的内存空间是多么困难的事情。在大型应用程序中，由于在释放某块动态内存前将指向该内存区域的指针重新赋值，从而使得此内存区域无法被释放的情况是十分常见的。通常将内存分配后没有被释放而导致可用内存减少称之为内存泄漏。避免内存泄漏耗尽系统资源正是许多服务器每隔一段时间就需要重新启动的原因。另外还要注意，由于分配动态内存时，用户得到的是一块void类型的内存，用户可以将其作为任何类型的内存空间使用，也可能引发一些无法预计的结果。</p>
<p>2、    动态内存的分配<br>分配动态内存空间所使用的函数调用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void *malloc(size_t size);</span><br><span class="line">void *calloc(size_t nmemb, size_t size);</span><br></pre></td></tr></table></figure>
<p>函数malloc和calloc都是用于分配动态内存空间的函数。<br>函数malloc的参数size表示申请分配的内存空间的大小，以字节记。<br>函数calloc的参数nmemb表示申请分配的内存空间占的数据项数目，参数size表示一个数据项的大小，以字节记。也就是说，calloc函数分配大小为nmemb*size大小的内存空间。<br>函数calloc与函数malloc的最大区别就是函数calloc将初始化所分配的内存空间，把所有位置0。调用成功时，函数calloc与函数malloc的返回值都为被分配的内存空间的指针；调用失败时，返回值为NULL。</p>
<p>3、    动态内存的释放<br>    释放动态内存空间所使用的函数调用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void free(void *ptr);</span><br></pre></td></tr></table></figure>
<pre><code>此函数的作用是释放由函数calloc或函数malloc分配的动态内存。参数ptr是指向要释放的动态内存的指针。</code></pre><p>注意：当动态内存被释放后，原来指向它的指针就会变为悬空指针。此时使用该指针将会产生错误。</p>
<p>4、    调整动态内存的大小<br>对于用函数calloc与函数malloc分配好的动态内存，可以使用realloc函数来调整它的大小。该函数的说明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">       void*realloc(void *ptr, size_t size);</span><br></pre></td></tr></table></figure>
<p>realloc函数的作用是重新调整一块动态内存区域的大小，参数ptr是指向要调整的动态内存的指针，应是函数calloc与函数malloc的返回值。参数size是新定义的动态内存的大小。Size可以大于或小于动态内存的原大小，调用realloc函数时，通常是在原来的内存空间调整动态内存的大小，原有数据不被改动。当size大于原大小，而原位置中无法完成调整时，将重新开辟内存空间并将原数据拷贝到新的内存空间中。<br>注意：如果参数ptr为NULL，则函数realloc的作用相当于函数malloc。如果参数size为0，则函数realloc的作用相当于函数free。</p>
<p>5、    使用链表进行动态内存的分配<br>虽然使用动态内存可以方便地使用内存，但动态内存也有局限性，就是在数据输入到程序之前必须知道数据的大小，以便申请相应的动态内存。然而，在很多情况下，用户都无法事先知道这个值，因而也就无法申请相应的内存空间。对于这种事先未知大小的数据输入，可以使用链表将其分块保存。<br>链表是一种动态地进行存储分配的结构。链表中的各个元素是一个结构，每个元素称为链表的一个结点。此结构中包含有一个指向此结构的指针，用于指向链表中的下一个结点。链表的最后一个结点的指针NULL，表示链表结束。</p>
<p>6.与用户空间相关的系统调用<br><img src="https://s1.ax1x.com/2020/04/12/GO8QRs.png" alt="avator"><br><img src="https://s1.ax1x.com/2020/04/12/GO8MGj.png" alt="avator"></p>
<h1 id="详细过程操作与分析"><a href="#详细过程操作与分析" class="headerlink" title="详细过程操作与分析"></a>详细过程操作与分析</h1><p>1.利用malloc和 calloc函数实现动态内存的分配；利用free函数实现动态内存的释放；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">char *upcase(char *inputstring);</span><br><span class="line">char *capitao(int size,char *inputstring);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    	char *str1, *str2;</span><br><span class="line">    </span><br><span class="line">    	str1&#x3D;upcase(&quot;Hello&quot; );</span><br><span class="line">    	str2&#x3D;capitao(strlen(&quot;Goodbye&quot;),&quot;Goodbye&quot;);</span><br><span class="line"></span><br><span class="line">    	printf(&quot;str1&#x3D;%s, str2&#x3D;%s\n&quot;, str1, str2);</span><br><span class="line"></span><br><span class="line">    	free(str1);</span><br><span class="line">    	free(str2);</span><br><span class="line"></span><br><span class="line">    	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char *upcase(char *inputstring)</span><br><span class="line">&#123;</span><br><span class="line">    	char *newstring;</span><br><span class="line">    	int counter;</span><br><span class="line"></span><br><span class="line">    	if(!(newstring&#x3D;malloc(strlen(inputstring)+1)))</span><br><span class="line">	&#123;</span><br><span class="line">    		printf(&quot;ERROR ALLOCATING MEMORY! \n&quot;);</span><br><span class="line">    		exit(255);</span><br><span class="line">	&#125;</span><br><span class="line">    	strcpy(newstring, inputstring);</span><br><span class="line">	for(counter&#x3D;0; counter&lt;strlen(newstring); counter++)</span><br><span class="line">	&#123;</span><br><span class="line">        	if(newstring[counter]&gt;&#x3D;97&amp;&amp;newstring[counter]&lt;&#x3D;122)</span><br><span class="line">             		newstring[counter]-&#x3D;32;</span><br><span class="line">	&#125;</span><br><span class="line">	return newstring;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *capitao(int size,char *inputstring)</span><br><span class="line">&#123;</span><br><span class="line">    	char *newstring;</span><br><span class="line">    	int counter;</span><br><span class="line"></span><br><span class="line">    	if(!(newstring&#x3D;calloc(size,sizeof(char))))</span><br><span class="line">	&#123;</span><br><span class="line">    		printf(&quot;ERROR ALLOCATING MEMORY! \n&quot;);</span><br><span class="line">    		exit(255);</span><br><span class="line">	&#125;</span><br><span class="line">    	strcpy(newstring, inputstring);</span><br><span class="line">	for(counter&#x3D;0; counter&lt;strlen(newstring); counter++)</span><br><span class="line">	&#123;</span><br><span class="line">        	if(newstring[counter]&gt;&#x3D;97&amp;&amp;newstring[counter]&lt;&#x3D;122)</span><br><span class="line">             		newstring[counter]-&#x3D;32;</span><br><span class="line">	&#125;</span><br><span class="line">	return newstring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://s1.ax1x.com/2020/04/12/GO8oOP.png" alt="avator"></p>
<p>2.利用realloc函数实现调整内存空间的大小；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">char* upcase(char *inputstring, char *newstring);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    	char *string;</span><br><span class="line">    </span><br><span class="line">    	string &#x3D; upcase(&quot;Hello&quot;,string);</span><br><span class="line">    	printf(&quot;str1&#x3D;%s \n&quot;, string);</span><br><span class="line">	string &#x3D; upcase(&quot;Goodbye&quot;, string);</span><br><span class="line">    	printf(&quot;str2&#x3D;%s\n&quot;, string);</span><br><span class="line"></span><br><span class="line">    	free(string);</span><br><span class="line"></span><br><span class="line">    	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char* upcase(char *inputstring, char *newstring)</span><br><span class="line">&#123;</span><br><span class="line">    	int counter;</span><br><span class="line"></span><br><span class="line">    	if(!newstring)</span><br><span class="line">    	&#123;</span><br><span class="line">		&#x2F;&#x2F;第一个参数ptr为NULL，则函数realloc的作用相当于函数malloc</span><br><span class="line">        	if(!(newstring&#x3D;realloc(NULL, strlen(inputstring)+1)))</span><br><span class="line">		&#123;</span><br><span class="line">        		printf(&quot;ERROR ALLOCATING MEMORY! \n&quot;);</span><br><span class="line">        		exit(255);</span><br><span class="line">		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	else</span><br><span class="line">    	&#123;</span><br><span class="line">        	if(!(newstring&#x3D;realloc(newstring, sizeof(inputstring)+1)))</span><br><span class="line">        	&#123;</span><br><span class="line">        		printf(&quot;ERROR REALLOCATING MEMORY! \n&quot;);</span><br><span class="line">        		exit(255);</span><br><span class="line">    		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">        strcpy(newstring, inputstring);</span><br><span class="line">	for(counter&#x3D;0; counter&lt;strlen(newstring); counter++)</span><br><span class="line">	&#123;</span><br><span class="line">        	if(newstring[counter]&gt;&#x3D;97&amp;&amp;newstring[counter]&lt;&#x3D;122)</span><br><span class="line">             		newstring[counter]-&#x3D;32;</span><br><span class="line">	&#125;</span><br><span class="line">	return newstring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://s1.ax1x.com/2020/04/12/GO8Hw8.png" alt="avator"></p>
<p>3.利用链表结构，malloc函数和 free函数实现将终端输入的一系列字符串用链表的形式保存下来。然后再将这些数据组装起来，回显到输出终端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define DATASIZE 10</span><br><span class="line"></span><br><span class="line">typedef struct stringdata</span><br><span class="line">&#123;</span><br><span class="line">    	char *string;</span><br><span class="line">    	int iscontinuing;</span><br><span class="line">    	struct stringdata *next;</span><br><span class="line">&#125; mydata;</span><br><span class="line"></span><br><span class="line">mydata *append(mydata *start, char *input);</span><br><span class="line">void displaydata(mydata *start);</span><br><span class="line">void freedata(mydata *start);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    	char input[DATASIZE];</span><br><span class="line">    	mydata *start&#x3D;NULL;</span><br><span class="line"></span><br><span class="line">    	printf(&quot;ENTER SOME DATA,AND PRESS Ctrl+D WHEN DONE. \n&quot;);</span><br><span class="line"></span><br><span class="line">    	while(fgets(input, sizeof(input), stdin))</span><br><span class="line">    	&#123;</span><br><span class="line">        	start&#x3D;append(start, input);</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	displaydata(start);</span><br><span class="line">    	freedata(start);</span><br><span class="line">    	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mydata *append(mydata *start, char *input)</span><br><span class="line">&#123;</span><br><span class="line">   	mydata *cur&#x3D;start, *prev&#x3D;NULL, *new;</span><br><span class="line"></span><br><span class="line">    	while(cur)</span><br><span class="line">    	&#123;</span><br><span class="line">        	prev&#x3D;cur;</span><br><span class="line">        	cur&#x3D;cur-&gt;next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	cur&#x3D;prev;</span><br><span class="line"></span><br><span class="line">    	new&#x3D;malloc(sizeof(mydata));</span><br><span class="line">    	if(!new)</span><br><span class="line">    	&#123;</span><br><span class="line">        	printf(&quot;COULDN’T ALLOCATE MEMORY! \n&quot;);</span><br><span class="line">        	exit(255);</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    	if(cur)</span><br><span class="line">        	cur-&gt;next&#x3D;new;</span><br><span class="line">    	else</span><br><span class="line">        	start&#x3D;new;</span><br><span class="line">    </span><br><span class="line">    	cur&#x3D;new;</span><br><span class="line"></span><br><span class="line">	if(!(cur-&gt;string&#x3D;malloc(sizeof(input)+1)))</span><br><span class="line">	&#123;</span><br><span class="line">    		printf(&quot;ERROR ALLOCATING MEMORY! \n&quot;);</span><br><span class="line">    		exit(255);</span><br><span class="line">	&#125;</span><br><span class="line">	strcpy(cur-&gt;string, input);</span><br><span class="line">	cur-&gt;iscontinuing&#x3D;!(input[strlen(input)-1]&#x3D;&#x3D;&#39;\n&#39;||input[strlen(input)-1]&#x3D;&#x3D;&#39;\r&#39;);</span><br><span class="line">	cur-&gt;next&#x3D;NULL;</span><br><span class="line"></span><br><span class="line">	return start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void displaydata(mydata *start)</span><br><span class="line">&#123;</span><br><span class="line">    	mydata *cur;</span><br><span class="line">	int linecounter&#x3D;0, structcounter&#x3D;0;</span><br><span class="line">	int newline&#x3D;1;</span><br><span class="line"></span><br><span class="line">	cur&#x3D;start;</span><br><span class="line">	while(cur)</span><br><span class="line">	&#123;</span><br><span class="line">    		if(newline)</span><br><span class="line">        		printf(&quot;LINE %d:&quot;,++linecounter);</span><br><span class="line">    		structcounter++;</span><br><span class="line">    		printf(&quot;%s&quot;,cur-&gt;string);</span><br><span class="line">    		newline&#x3D;!cur-&gt;iscontinuing;</span><br><span class="line">    		cur&#x3D;cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;THIS DATA CONTAINED %d LINES AND WAS STORED IN %d STRUCTS. \n&quot;,</span><br><span class="line">	linecounter,structcounter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void freedata(mydata *start)</span><br><span class="line">&#123;</span><br><span class="line">    	mydata *cur, *next&#x3D;NULL;</span><br><span class="line"></span><br><span class="line">    	cur&#x3D;start;</span><br><span class="line">    	while(cur)</span><br><span class="line">    	&#123;</span><br><span class="line">        	next&#x3D;cur-&gt;next;</span><br><span class="line">       		free(cur-&gt;string);</span><br><span class="line">        	free(cur);</span><br><span class="line">        	cur&#x3D;next;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<br><img src="https://s1.ax1x.com/2020/04/12/GOGqnx.png" alt="avator"></p>
<p>4.编写一个内核模块，打印进程的虚存区，其中通过模块参数把进程的PID传递给模块。<br>创建进程的程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int agrc,char **argc)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	unsigned char *buff;</span><br><span class="line">	buff &#x3D; (char*)malloc(sizeof(char)*1024);</span><br><span class="line">	printf(&quot;My pid is:%d\n&quot;,getpid());</span><br><span class="line">	for(i &#x3D; 0;i &lt; 60;i++)&#123;</span><br><span class="line">		sleep(60);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个存放自定义内核模块的文件夹3-4</p>
<p>编写内核模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;interrupt.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;sched.h&gt;</span><br><span class="line"></span><br><span class="line">static int pid;</span><br><span class="line"></span><br><span class="line">module_param(pid,int,0644);</span><br><span class="line"></span><br><span class="line">static int __init memtest_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct task_struct* p;</span><br><span class="line">    struct vm_area_struct* temp;</span><br><span class="line">    printk(&quot;The virtual memory areas(VMA) are:\n&quot;);</span><br><span class="line">    p&#x3D;pid_task(find_vpid(pid),PIDTYPE_PID);</span><br><span class="line">    temp&#x3D;p-&gt;mm-&gt;mmap;</span><br><span class="line"></span><br><span class="line">    while(temp)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;start:%p\tend:%p\n&quot;,(unsigned long *)temp-&gt;vm_start,(unsigned long *)temp-&gt;vm_end);</span><br><span class="line">        temp&#x3D;temp-&gt;vm_next;</span><br><span class="line">    &#125;       </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit memtest_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;Unloading my module.\n&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(memtest_init);</span><br><span class="line">module_exit(memtest_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<p>Makefile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj-m :&#x3D; 4-2.o  </span><br><span class="line">#generate the path  </span><br><span class="line">CURRENT_PATH:&#x3D;$(shell pwd)  </span><br><span class="line">#the current kernel version number  </span><br><span class="line">LINUX_KERNEL:&#x3D;$(shell uname -r)  </span><br><span class="line">#the absolute path  </span><br><span class="line">LINUX_KERNEL_PATH:&#x3D;&#x2F;usr&#x2F;src&#x2F;linux-headers-$(LINUX_KERNEL)  </span><br><span class="line">#complie object  </span><br><span class="line">all:  </span><br><span class="line">	 make -C $(LINUX_KERNEL_PATH) M&#x3D;$(CURRENT_PATH) modules  </span><br><span class="line">#clean  </span><br><span class="line">clean:  </span><br><span class="line">	 make -C $(LINUX_KERNEL_PATH) M&#x3D;$(CURRENT_PATH) clean</span><br></pre></td></tr></table></figure>

<p>make编译<br><img src="https://s1.ax1x.com/2020/04/12/GOGjAO.png" alt="avator"></p>
<p>编译创建进程的程序，并让其在后台运行：<br><img src="https://s1.ax1x.com/2020/04/12/GOGHj1.png" alt="avator"></p>
<p>cd进入刚才编写的内核模块，带参数插入模块<br><img src="https://s1.ax1x.com/2020/04/12/GOGLB6.png" alt="avator"></p>
<p>查看输出信息：<br><img src="https://s1.ax1x.com/2020/04/12/GOGOHK.png" alt="avator"></p>
<p>查看proc文件系统读取到的信息：<br><img src="https://s1.ax1x.com/2020/04/12/GOGvND.png" alt="avator"></p>
<p>两者输出的信息是一致的！<br>通过这个简单地例子可以看出，一个进程的虚拟地址空间是由一个个虚存区组成的。对进程用户空间的管理在很大程度上依赖于对虚存区的管理</p>
<p>5.映射一个4字节大小的匿名区，父进程和子进程共享这个匿名区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 10</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i, sum, fd;</span><br><span class="line">	int *result_ptr &#x3D; mmap(0, 4, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);</span><br><span class="line">	int pid &#x3D; fork();</span><br><span class="line">	if(pid &#x3D;&#x3D; 0)&#123;	&#x2F;* 子进程，进行计算*&#x2F;</span><br><span class="line">		for(sum &#x3D; 0,i &#x3D; 1;i &lt;&#x3D; N;i++)&#123;</span><br><span class="line">			sum +&#x3D; i;		</span><br><span class="line">		&#125;	</span><br><span class="line">		*result_ptr &#x3D; sum;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		wait(0);	&#x2F;*父进程，等待计算结果*&#x2F;	</span><br><span class="line">		printf(&quot;result &#x3D; %d\n&quot;, *result_ptr);</span><br><span class="line">	&#125;</span><br><span class="line">    	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://s1.ax1x.com/2020/04/12/GOYpIU.png" alt="avator"></p>
<p>6.映射一个名为“test-data”的文件，文件包含的内容为“Hello World”</p>
<p>数据文件test-data</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>源代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define N 10</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i, fd;</span><br><span class="line">	char *buf;</span><br><span class="line">	fd &#x3D; open(&quot;test-data&quot;,O_RDONLY);</span><br><span class="line">	buf &#x3D; mmap(0, 12, PROT_READ, MAP_PRIVATE, fd, 0);</span><br><span class="line">	for(i &#x3D; 0;i &lt; 12;i++)&#123;</span><br><span class="line">		printf(&quot;%c\n&quot;,buf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">    	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/04/12/GOYCiF.png" alt="avator"></p>
<p>【分析】<br>我们希望通过访问用户空间的内存达到读取内核数据的目的，这样便可以进行内核空间到用户空间的大规模信息传送，从而应用于高速数据采集等性能要求高的场合。<br>因为通过外设采集的数据首先会由驱动程序放入内核，然后才传送到用户空间由用户程序做进一步的处理。由于内核内存是受保护的。<br>因此，要想将其数据拷贝到用户空间，通常的方法是利用系统调用，但是系统调用的缺点是速度慢，这回成为高速处理的瓶颈。因此我们希望可以从用户空间直接读取内核数据，从而省去数据在两个空间拷贝的过程。具体的讲，我们要利用内存映射功能，将内核中的一部分虚拟内存映射到用户空间，使得访问用户空间地址等同于访问被映射的内核空间地址，从而不再需要数据拷贝操作。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁CAS</title>
    <url>/2019/09/22/%E4%B9%90%E8%A7%82%E9%94%81CAS/</url>
    <content><![CDATA[<h3 id="乐观锁CAS"><a href="#乐观锁CAS" class="headerlink" title="乐观锁CAS"></a>乐观锁CAS</h3><p>下面的程序中我们可能会使用synchronized关键字来保证得到的num是正确的。但是这样会让没有得到锁的线程进入blocked状态，当拿到锁之后恢复到runnable状态，这个过程设计操作系统的用户模式和内核模式的切换。<br><br>Java从jdk1.5开始提供了<strong>java.util.concurrent.atomic</strong>包，这个包下有很多的原子类操作。例如常用的原子更新基本类型的<strong>AtomicBoolean，AtomicInteger，AtomicLong</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.jiasheng.CAS;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class TestCAS &#123;</span><br><span class="line">    private static AtomicInteger num &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public static void add() &#123;</span><br><span class="line">        &#x2F;&#x2F;num++；不是原子性擦操作，加上synchronized可以解决，但是严重降低了性能</span><br><span class="line">        num.incrementAndGet(); &#x2F;&#x2F; AtomicInteger +1方法，底层是CAS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 5000; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(Thread.activeCount() &gt; 2)&#123; &#x2F;&#x2F;main gc</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原子操作类的底层利用的正是CAS机制，全称即Compare and Swap。<br><br><br>先看一下compareAndSet源码：<br><br>调用这个方法传递的参数expect和update，expect期望值就是我们期望内存中某个变量的旧值是什么，update新值就是我们希望修改成什么值。valueOffset据说是一个偏移地址？不过不重要，这个不是重点，只要知道它是一个volatile修饰的变量即可。<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compareAndSet调用的compareAndSwapInt方法使用C++实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure>

<p>我们现在来看一下上面程序中++操作的incrementAndGet的源码：<br><br><strong>AtomicInteger.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Atomically increments by one the current value.</span><br><span class="line"> *</span><br><span class="line"> * @return the updated value</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delta就是需要自增的值，incrementAndGet传进来的是1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAdd(int delta) &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的unsafe类的getAndAddInt方法，继续查看这个方法的源码：<br><br><strong>unsafe.java</strong><br><br>这里var1是实例，var2就是偏移地址，var3就是上面的delta，这里是1<br><br>while循环中第三个参数var5就是expect值，var5+var4就是update值，var5这个值是根据this.getIntVolatile(var1, var2);计算出来的，就是读取到这个时刻内存这边旧值的最新值，因为有可能A线程准备替换之前，已经被B线程更新了，即两个线程都执行到了getIntVolatile方法。所以需要把var5更新到当前时刻的最新值。<br><br>while循坏就是判断就是except（也即var5）是否是线程A一开始希望的那个值，要确保是当前状态的最新值。</p>
<p><br>这里的while循环也叫作CAS自旋。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getAndAddInt方法里面调用的下面这两个方法都是native修饰的方法，即底层是C++实现的。效率会比自增操作高很多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int getIntVolatile(Object var1, long var2);</span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure>

<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ol>
<li>在高并发的场景下，如果多个线程都去反复尝试更新某一个相同的变量，但期望值却一直被改变了，就会造成循环次数很多，造成CPU很大的开销。</li>
<li>可能造成ABA问题。如果一个变量的值原来是A，先修改成B，然后又修改回A，使用CAS机制的话，无法分辨当前的except值是否已经发生过变化。</li>
</ol>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu环境下执行sudo apt-get update出现无法获得锁 /var/lib/apt/lists/lock - open的问题解决方法</title>
    <url>/2019/09/15/%E6%89%A7%E8%A1%8Csudo%20apt-get%20update%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/03/14/8QXxbt.png" alt="avator"></p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>执行ps -e | grep apt找到占用系统源更新时的系统锁的进程<br><img src="https://s1.ax1x.com/2020/03/14/8QjJq1.png" alt="avator"></li>
</ol>
<p>2.结束占用它的线程，输入命令sudo kill 进程ID号<br>再次执行 ps -e | grep apt，发现已经没有占用apt -get的进程了<br><img src="https://s1.ax1x.com/2020/03/14/8QjtVx.png" alt="avator"></p>
<ol start="3">
<li>输入sudo apt-get update，成功！</li>
</ol>
]]></content>
      <tags>
        <tag>问题解决</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是fail-fast？什么是fail-safe？</title>
    <url>/2019/09/15/%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFfail-safe%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是fail-fast？什么是fail-safe？"><a href="#什么是fail-fast？什么是fail-safe？" class="headerlink" title="什么是fail-fast？什么是fail-safe？"></a>什么是fail-fast？什么是fail-safe？</h1><h2 id="fail-fast快速失效机制。"><a href="#fail-fast快速失效机制。" class="headerlink" title="fail-fast快速失效机制。"></a>fail-fast快速失效机制。</h2><p>这是在Java集合框架中的一种机制。当多个线程对同一个集合的内容进行操作时（并发操作），就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>下面是ArrayLlist结合源码中，堆这种机制的解释。</p>
<p>除了iterator自己本身的方法，如remove和add对集合结构作出修改不会抛出异常，其它意图修改集合结构的行为，都会抛出ConcurrentModificationException。<br><img src="https://s1.ax1x.com/2020/04/06/GyGU1K.png" alt="avator"></p>
<p>迭代器的快速失败机制是没有保证的，也就是这种机制是尽自己的最大努力抛出ConcurrentModificationException异常。官方的建议是fast-fail最好用于检测bug中。<br><img src="https://s1.ax1x.com/2020/04/06/GyGNp6.png" alt="avator"></p>
<p>查看ArrayList中关于Iterator的部分源码：<br><br>可以看到next()等函数时都会先调用checkForComodification函数来检查modCount 和expectedModCount是否相等，如果不相等，则会抛出异常。<br><br>通过上面的remove函数（clear和sort等也会）的源码，我们知道modCount会++，所以如果在迭代器遍历元素的时候，修改了modeCount，也就是进行了remove操作，就会触发fail-fast机制抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h2><p>fail-safe很明显，就是一种安全机制，不会像fail-fast那样抛出ConcurrentModificationException异常。</p>
<p>原因：如果在遍历的过程中，集合的结构被修改了，那么触发fail-safe机制，会把原集合的复制一份，继续在复制后的集合中遍历。</p>
<p>缺点：复制会消耗额外的时间和空间开销，并且不能保证遍历的是最新的数据。<br><img src="https://s1.ax1x.com/2020/04/06/GyGJt1.png" alt="avator"></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出ABA问题</title>
    <url>/2019/09/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAABA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="什么是ABA问题？"><a href="#什么是ABA问题？" class="headerlink" title="什么是ABA问题？"></a>什么是ABA问题？</h3><p>如果一个变量的值原来是A，先修改成B，然后又修改回A，使用<strong>CAS机制</strong>的话，无法分辨当前的except值是否已经发生过变化。（可先理解一下什么是CAS机制）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.CAS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建两个线程</span></span><br><span class="line"><span class="comment"> * A线程需要把2改成3</span></span><br><span class="line"><span class="comment"> * B线程先把2改成6，再把6改回2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestABA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 开启，num = "</span> + atomicInteger);</span><br><span class="line">            <span class="comment">//A线程休眠2s，让出CPU给其他线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS操作一波</span></span><br><span class="line">            <span class="keyword">boolean</span> except = atomicInteger.compareAndSet(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">"cas is success ? "</span> + except);</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//保证main线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicInteger.incrementAndGet();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"increment, num = "</span> + atomicInteger);</span><br><span class="line"></span><br><span class="line">            atomicInteger.decrementAndGet();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"decrement, num = "</span> + atomicInteger);</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/22/8oQT9P.png" alt="avator"></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以给竞争资源加锁，但是这样性能会降低。所以，我们使用<strong>AtomicStampedReference</strong>类。这是一个原子更新带有<strong>版本号</strong>的引用类型，每次操作都会更改版本号。</p>
<p><strong>构造函数</strong><br>initialRef初始值，initialStamp初始版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public AtomicStampedReference(V initialRef, int initialStamp) &#123;</span><br><span class="line">    pair &#x3D; Pair.of(initialRef, initialStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getReference方法</strong><br><br>作用：返回当前版本号下的变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns the current value of the reference.</span><br><span class="line"> *</span><br><span class="line"> * @return the current value of the reference</span><br><span class="line"> *&#x2F;</span><br><span class="line">public V getReference() &#123;</span><br><span class="line">    return pair.reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getStamp方法</strong><br><br>作用：返回变量当前值的版本号，即获取最新的版本号是多少</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns the current value of the stamp.</span><br><span class="line"> *</span><br><span class="line"> * @return the current value of the stamp</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int getStamp() &#123;</span><br><span class="line">    return pair.stamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>compareAndSet方法</strong><br><br>expectedReference：旧的值<br><br>newReference：新的值，就是我们想要修改为什么值<br><br>expectedStamp：旧的版本号<br><br>newStamp：新的版本号，一般是expectedStamp+1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   newReference,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current &#x3D; pair;</span><br><span class="line">    return</span><br><span class="line">        expectedReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">        expectedStamp &#x3D;&#x3D; current.stamp &amp;&amp;</span><br><span class="line">        ((newReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">          newStamp &#x3D;&#x3D; current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改上述存在ABA问题的程序"><a href="#修改上述存在ABA问题的程序" class="headerlink" title="修改上述存在ABA问题的程序"></a>修改上述存在ABA问题的程序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.CAS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolveABA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 开启，num = "</span> + stampedReference.getReference());</span><br><span class="line">            <span class="comment">//当前标识</span></span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            <span class="comment">//A线程休眠2s，让出CPU给其他线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS操作一波</span></span><br><span class="line">            <span class="keyword">boolean</span> except = stampedReference.compareAndSet(<span class="number">2</span>, <span class="number">3</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"cas is success ? "</span> + except);</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//保证main线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">2</span>, <span class="number">6</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"increment, num = "</span> + stampedReference.getReference());</span><br><span class="line"></span><br><span class="line">            stampedReference.compareAndSet(<span class="number">6</span>, <span class="number">2</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"decrement, num = "</span> + stampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong><br><img src="https://s1.ax1x.com/2020/03/22/8oQ4AA.png" alt="avator"></p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis快速入门</title>
    <url>/2019/08/12/Mybatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><ul>
<li>列表1</li>
<li>列表2<br>  快速入门系列</li>
</ul>
<p>1、简介</p>
<p>1.1、什么是MyBatis<br>简介<br>什么是 MyBatis？<br>MyBatis 是一款优秀的持久层框架<br>它支持定制化 SQL、存储过程以及高级映射。<br>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。<br>如何获得MyBatis？<br>Maven仓库</p>
]]></content>
      <tags>
        <tag>框架</tag>
        <tag>Mybatis</tag>
        <tag>Java</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread技术点</title>
    <url>/2019/08/09/Thread%E6%8A%80%E6%9C%AF%E7%82%B9/</url>
    <content><![CDATA[<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>Thread类实现Runnable接口，继承自Objeact类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Thread</span><br><span class="line">extends Object</span><br><span class="line">implements Runnable</span><br></pre></td></tr></table></figure>

<p>start() 方法，使该线程开始执行，Java虚拟机调用该线程的run方法。调用该方法之后线程就会进入就绪状态，不是一定会成为运行状态！！</p>
<p>stop() 方法，调用该方法强制结束该线程结束</p>
<p>sleep() 方法，调用该方法该线程进入等待状态</p>
<p>run() 方法，调用该方法直接执行线程的run方法。和start方法不同的是，start方法是让线程调度执行run方法。</p>
<h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><p>sleep方法底层是native修饰的c++编写的方法。</p>
<p>在源码中的说明是，当线程执行此方法时，并不会失去对monitor的掌握权。即只会会当前线程睡眠一会。</p>
<p>Thead.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;The thread does not lose ownership of any monitors.</span><br><span class="line">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure>

<p>Object.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>

<p>【细节】一般使用sleep使用的是java.util.concurrent包下TimeUnit类的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TimeUnit.SECONDS.sleep(2);</span><br></pre></td></tr></table></figure>

<p>1.wait是Object类的方法，sleep是Thead类的方法</p>
<p>2.wait会释放锁，所以只能在synchronized方法或synchronized块中使用；sleep不会释放锁，可以在任何地方使用</p>
<p><strong>最主要的本质区别:</strong></p>
<p>Thread.sleep只会让出CPU,不会导致锁行为的改变</p>
<p>Object.wait不仅让出CPU，还会释放已经占有的同步资源锁</p>
<h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>yield只是简单地对CPU时间片的礼让，除非循环yield，否则一次yield可能下次该线程仍旧可能会抢占到CPU时间片。</p>
<h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>底层还是wait方法</p>
<p>哪个线程调用x.join()，哪个线程（下面例子就是main线程）就挂起。并且join要start调用之后。</p>
<p>Join()方法，使调用此方法的线程wait()（在例子中是main线程）,直到调用此方法的线程对象（在例子中是thread1对象）所在的线程（在例子中是子线程）执行完毕后被唤醒。</p>
<p>比如主线程main中调用启动线程（调用start），然后调用该线程的join方法，可以达到主线程等待工作线程运行结束之后才执行的效果，并且join要在start调用后。</p>
<p>【示例】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread thread1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程1正在执行-----&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   thread1.start();</span><br><span class="line">   thread1.join();</span><br><span class="line">   System.out.println(&quot;main线程&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">main线程</span><br></pre></td></tr></table></figure>

<p>【注意】如果start在join之后，就不能保证main线程需要等待thread1运行结束之后才运行了。如上面的例子修改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread1.join();</span><br><span class="line">thread1.start();</span><br><span class="line">System.out.println(&quot;main线程&quot;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main线程</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br></pre></td></tr></table></figure>

<p>【源码分析】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    long base &#x3D; System.currentTimeMillis();</span><br><span class="line">    long now &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            long delay &#x3D; millis - now;</span><br><span class="line">            if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>按Z字形打印二叉树</title>
    <url>/2019/08/05/%E6%8C%89Z%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; out = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        list.offer(pRoot);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//左-&gt;右</span></span><br><span class="line">        TreeNode last = pRoot;</span><br><span class="line">        TreeNode nLast = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                pRoot = list.pollFirst();</span><br><span class="line">                <span class="keyword">if</span>(pRoot.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.offerLast(pRoot.left);</span><br><span class="line">                    nLast = nLast == <span class="keyword">null</span> ? pRoot.left : nLast;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pRoot.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.offerLast(pRoot.right);</span><br><span class="line">                    nLast = nLast == <span class="keyword">null</span> ? pRoot.right : nLast;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pRoot = list.pollLast();</span><br><span class="line">                <span class="keyword">if</span>(pRoot.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.offerFirst(pRoot.right);</span><br><span class="line">                    nLast = nLast == <span class="keyword">null</span> ? pRoot.right : nLast;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pRoot.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.offerFirst(pRoot.left);</span><br><span class="line">                    nLast = nLast == <span class="keyword">null</span> ? pRoot.left : nLast;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            out.add(pRoot.val);</span><br><span class="line">            <span class="keyword">if</span>(pRoot == last)&#123;</span><br><span class="line">                res.add(out);</span><br><span class="line">                out = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                flag = !flag;</span><br><span class="line">                last = nLast;</span><br><span class="line">                nLast = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>双端队列</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>不用加减乘除做加法</title>
    <url>/2019/08/05/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            temp = num1 ^ num2;</span><br><span class="line">            num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>和为S的两个数字</title>
    <url>/2019/08/05/%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> m = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length; i++)&#123;</span><br><span class="line">            map.put(sum-array[i], array[i]);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(array[i]))&#123;</span><br><span class="line">                <span class="keyword">int</span> n = array[i] * map.get(array[i]);</span><br><span class="line">                <span class="keyword">if</span>(m &gt; n)&#123;</span><br><span class="line">                    num[<span class="number">0</span>] = map.get(array[i]);</span><br><span class="line">                    num[<span class="number">1</span>] = array[i];</span><br><span class="line">                    m = n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>] != <span class="number">0</span> &amp;&amp; num[<span class="number">1</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            list.add(num[<span class="number">0</span>]);</span><br><span class="line">            list.add(num[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int i = 0;</span></span><br><span class="line"><span class="comment">        int j = array.length - 1;</span></span><br><span class="line"><span class="comment">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        while(i &lt; j)&#123;</span></span><br><span class="line"><span class="comment">            int s = array[i] + array[j];</span></span><br><span class="line"><span class="comment">            if(s == sum)&#123;</span></span><br><span class="line"><span class="comment">                list.add(array[i]);</span></span><br><span class="line"><span class="comment">                list.add(array[j]);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125; else if (s &lt; sum) &#123;</span></span><br><span class="line"><span class="comment">                i++;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                j--;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return list;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>圆圈中最后剩下的数</title>
    <url>/2019/08/05/%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>如果没有小朋友，请返回-1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">       LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">           list.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            k = (k+m-<span class="number">1</span>)%list.size();</span><br><span class="line">            list.remove(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>约瑟夫环</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的下一个节点</title>
    <url>/2019/08/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前驱节点和后继节点是在二叉树中序遍历的场景下面讨论的。<br>暴力解法：遍历二叉树，建立哈希表。<br>优化：<br>如果一个节点有右子树，那么它的后继节点就是右子树最左的节点。例如下图中，1的后继节点是6.<br>如果一个节点没有右子树，那么x指向当前节点，p指向x的父节点，若当前节点x是其父节点p的左孩子，则p就是原始节点的后继节点。以下图为例：<br>①x为11，p为5，5的左孩子不是11<br>②x变为5，p变为2，2的左孩子不是5<br>③x变为2，p变为1，1的左孩子是2<br>所以，原始节点11的后继节点是1。<br><img src="https://s1.ax1x.com/2020/04/12/GLlv3q.png" alt="avator"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//next指针指向父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode p = pNode.next;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.left != pNode)&#123;</span><br><span class="line">                pNode = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getRightMostLeft(pNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到右子树上最左的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">getRightMostLeft</span><span class="params">(TreeLinkNode node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">           node = node.left;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>字符流中第一个不重复的数字</title>
    <url>/2019/08/05/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Character&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(ch))&#123;</span><br><span class="line">            map.put(ch,<span class="number">1</span>);</span><br><span class="line">            list.add(ch);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(ch,map.get(ch)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(list.peek()) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> list.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            list.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的重复节点</title>
    <url>/2019/08/05/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode pre = node;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)&#123;</span><br><span class="line">                <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.next= cur.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = cur;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>对称的二叉树</title>
    <url>/2019/08/05/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/*    boolean isSymmetrical(TreeNode pRoot)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(pRoot == null) return true;</span></span><br><span class="line"><span class="comment">        return fun(pRoot.left, pRoot.right);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    boolean fun(TreeNode left, TreeNode right)&#123;</span></span><br><span class="line"><span class="comment">        if(left == null || right == null) return left == right;</span></span><br><span class="line"><span class="comment">        if(left.val != right.val) return false;</span></span><br><span class="line"><span class="comment">        return fun(left.left,right.right) &amp;&amp; fun(left.right, right.left);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(pRoot.left);</span><br><span class="line">        queue.offer(pRoot.right);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode left = queue.poll();</span><br><span class="line">            TreeNode right = queue.poll();</span><br><span class="line">            <span class="comment">//左右子树都为null</span></span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//左右子树其中一个为null</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="keyword">null</span> ^ right != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//左右子树都不为null</span></span><br><span class="line">            <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            queue.offer(left.left);</span><br><span class="line">            queue.offer(right.right);</span><br><span class="line">            queue.offer(left.right);</span><br><span class="line">            queue.offer(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/2019/08/05/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        n %= len;</span><br><span class="line">        String su = str.substring(n,len);</span><br><span class="line">        <span class="keyword">return</span> su+str.substring(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>把字符串转换为整数</title>
    <url>/2019/08/05/%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入一个字符串,包括数字字母符号,可以为空</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>如果是合法的数值表达则返回该数字，否则返回0</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+2147483647</span><br><span class="line">    1a33</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2147483647</span><br><span class="line">    0</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span> flag = chs[<span class="number">0</span>] == <span class="string">'-'</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = Integer.MAX_VALUE/<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.MAX_VALUE%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (chs[<span class="number">0</span>] == <span class="string">'+'</span> || chs[<span class="number">0</span>] == <span class="string">'-'</span>) ? <span class="number">1</span> : <span class="number">0</span>;i &lt; chs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chs[i] &lt; <span class="string">'0'</span> || chs[i] &gt; <span class="string">'9'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt;= m &amp;&amp; chs[i]-<span class="string">'0'</span> &gt; n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res*<span class="number">10</span> + chs[i]-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag &amp;&amp; res == Integer.MAX_VALUE+<span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag ? -res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>扑克牌的顺序</title>
    <url>/2019/08/05/%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zeroNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> gapNum = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">if</span>(numbers.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numbers.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                zeroNum++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == numbers[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                gapNum += numbers[i+<span class="number">1</span>]-numbers[i] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zeroNum &gt;= gapNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2019/08/05/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(numbers[i]))&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(numbers[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>求1+2+3+...+n</title>
    <url>/2019/08/05/%E6%B1%821+2+3+...+n/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        res = (<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>构建乘积数组</title>
    <url>/2019/08/05/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            B[i] = res*A[i];</span><br><span class="line">            res = B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>]*right;</span><br><span class="line">            right = right*A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        B[<span class="number">0</span>] = right;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转单词顺序列</title>
    <url>/2019/08/05/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String[] s = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(s.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = s.length - <span class="number">1</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(s[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中环的入口节点</title>
    <url>/2019/08/05/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode f = head.next.next;</span><br><span class="line">        ListNode s = head.next;</span><br><span class="line">        <span class="keyword">while</span>(s != f)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">if</span>(s == f)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s = s.next;</span><br><span class="line">            f = f.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        f = head;</span><br><span class="line">        <span class="keyword">while</span>(f != s)&#123;</span><br><span class="line">            f = f.next;</span><br><span class="line">            s = s.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>算法2</title>
    <url>/2019/08/02/%E8%AF%BB%E5%86%99%E9%94%81/</url>
    <content><![CDATA[<p>ReadWriteLock接口  </p>
<p>&emsp;&emsp;排他锁（如ReentratLock等），也叫互斥锁，在同一时刻只允许一个线程进行访问，而读写锁在同一个时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他线程均被阻塞。  </p>
<p>&emsp;&emsp;与互斥锁相比，读-写锁允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer 线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程），读-写锁利用了这一点。从理论上讲，与互斥锁相比，使用读-写锁所允许的并发性增强将带来更大的性能提高。在实践中，只有在多处理器上并且只在访问模式适用于共享数据时，才能完全实现并发性增强。  </p>
<p>&emsp;&emsp;不是所有情况都是读写锁并发性能更好的：与互斥锁相比，使用读-写锁能否提升性能则取决于读写操作期间读取数据相对于修改数据的频率，以及数据的争用——即在同一时间试图对该数据执行读取或写入操作的线程数。例如，某个最初用数据填充并且之后不经常对其进行修改的 collection，因为经常对其进行搜索（比如搜索某种目录），所以这样的 collection 是使用读-写锁的理想候选者。但是，如果数据更新变得频繁，数据在大部分时间都被独占锁，这时，就算存在并发性增强，也是微不足道的。更进一步地说，如果读取操作所用时间太短，则读-写锁实现（它本身就比互斥锁复杂）的开销将成为主要的执行成本，在许多读-写锁实现仍然通过一小段代码将所有线程序列化时更是如此。最终，只有通过分析和测量，才能确定应用程序是否适合使用读-写锁。</p>
<p>实现类ReentrantReadWriteLock3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReentrantReadWriteLock</span><br><span class="line">extends Object</span><br><span class="line">implements ReadWriteLock, Serializable</span><br></pre></td></tr></table></figure>
<p>实现了ReadWriteLock接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.rw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.读写锁ReadWriteLock</span></span><br><span class="line"><span class="comment"> * 写写/读写 互斥</span></span><br><span class="line"><span class="comment"> * 读读 不需要互斥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReadandWrite r = <span class="keyword">new</span> ReadandWrite();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                r.write(num);</span><br><span class="line">            &#125;, <span class="string">"write"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(r::read,<span class="string">"read"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadandWrite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//即使读共享，但还是要加读锁，否则在写的过程中还是可以读，就会造成脏读</span></span><br><span class="line">        <span class="comment">//所以这里读锁的意义不是限制单线程读，而是限制在写的时候不可以读</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"write"</span> + num);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"write ok"</span>);</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.readLock().lock();<span class="comment">//上锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" ok : "</span> + num);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>五段程序带你深刻理解单例模式</title>
    <url>/2019/08/02/%E4%BA%94%E6%AE%B5%E7%A8%8B%E5%BA%8F%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="五段程序带你深刻理解单例模式"><a href="#五段程序带你深刻理解单例模式" class="headerlink" title="五段程序带你深刻理解单例模式"></a>五段程序带你深刻理解单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式就是让一个类只能构建一个对象的设计模式</span></span><br><span class="line"><span class="comment"> * 此程序主要用于演示懒汉式和饿汉式</span></span><br><span class="line"><span class="comment"> *      饿汉式：在构造器之前就已经主动创建好实例。</span></span><br><span class="line"><span class="comment"> *      懒汉式：延迟实例化，等构造器来创建实例。</span></span><br><span class="line"><span class="comment"> * 问题：线程安全有隐患。</span></span><br><span class="line"><span class="comment"> *  如果多个线程同时调用getInstance方法，刚好都通过了判空的操作，开始执行new操作</span></span><br><span class="line"><span class="comment"> *  就会造成new重复多次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用静态变量来记录Singleton类的唯一实例</span></span><br><span class="line"><span class="comment">     * 它的初始值可以写成null，也可以写成new Singleton()</span></span><br><span class="line"><span class="comment">     * 分别可能造成懒汉式和饿汉式问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要让一个类只能构建一个对象，自然不能让它随便去做new操作，</span></span><br><span class="line"><span class="comment">     * 只有Hungry类里面才可以调用构造方法，因此Hungry的构造方法</span></span><br><span class="line"><span class="comment">     * 是私有的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂方法,获取单例对象。</span></span><br><span class="line"><span class="comment">     * 如果单例初始值instance是null，还未构建，则构建对象并返回。这种方式就是懒汉式,即延迟实例化。</span></span><br><span class="line"><span class="comment">     * 如果单例初始值一开始就通过new Singleton()主动创建，则不再需要判空操作。这种方式就是饿汉式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式</span></span><br><span class="line"><span class="comment"> * 破除第一版的线程安全问题</span></span><br><span class="line"><span class="comment"> * 方法一：在创建实例的方法加上synchronized，迫使每个线程在进入这个方法之前，要先等待其他线程</span></span><br><span class="line"><span class="comment"> *        离开该方法，也就是说，不会有两个线程同时进入这个方法，保证了线程安全。</span></span><br><span class="line"><span class="comment"> * 问题：严重影响性能！原因：只有第一次执行此方法，才真正需要同步，此后每次调用这个方法都是一种累赘</span></span><br><span class="line"><span class="comment"> * 同步一个方法可能造成程序执行效率下降100倍</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 方法二 ：DCL = double check lock  -&gt; 双重检测机制</span></span><br><span class="line"><span class="comment"> * 问题：存在指令重排问题（见下一个程序）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static synchronized Singleton2 getInstance()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一个if判断：只有当instance为null，才会向同步方法走去。如果没有这个if判断，则每次调用这个</span></span><br><span class="line"><span class="comment">     * getInstance方法，都会进入synchronized同步区，性能严重下降</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第二个if判断：假如有多个线程在同步方法入口那里，这时只能有一个线程（假设为A线程）可以进入</span></span><br><span class="line"><span class="comment">     * 同步代码块，如果是第一次进入，A线程在第二个if判断处判断为null，就会new Singleton2()。接着A线程</span></span><br><span class="line"><span class="comment">     * 退出synchronized区，此后即使有已经在synchronized处等待的线程进入同步代码块，还是会在第二个if判断处</span></span><br><span class="line"><span class="comment">     * 判定不为null，也就不会创建第二个instance。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式实现方式一：双重加锁机制+volatile</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new Singleton3()在多线程环境下存在指令重排问题</span></span><br><span class="line"><span class="comment"> * new Singleton3()会被编译器编程成如下的JVM指令：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * memory = allocate();  //1.分配对象的内存空间</span></span><br><span class="line"><span class="comment"> * ctorInstance(memory); //2.初始化对象</span></span><br><span class="line"><span class="comment"> * instance = memory;    //3.设置instance指向刚才分配的内存空间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这些指令顺序并不是一成不变的，有可能经过JVM和CPU的优化，指令重排为1 3 2</span></span><br><span class="line"><span class="comment"> * 当A线程执行完指令1,3之后，instance还未完成初始化工作，但是已经不再指向null</span></span><br><span class="line"><span class="comment"> * 此时B线程进来第一个if判断instance为null，就直接return instance;了，这样子</span></span><br><span class="line"><span class="comment"> * 返回的instance是空的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解决：使用volatile禁止指令重排</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 存在问题：可以通过反射new多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式实现方式二：静态内部类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 存在问题：可以通过反射new多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类，外部无法访问，只有当调用Singleton4.getInstance()方法时，才能</span></span><br><span class="line"><span class="comment">     * 得到单例对象。</span></span><br><span class="line"><span class="comment">     * 【注意】单例对象instance初始化的时机并不是在单例类Singleton4被加载的时候，</span></span><br><span class="line"><span class="comment">     * 而是在调用getInstance()方法，使得静态内部类LazyHolder被加载的时候。</span></span><br><span class="line"><span class="comment">     * 因此，这种实现方式是利用ClassLoader的加载机制来实现懒加载的，并保证构建单例的线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton4 instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> LazyHolder.instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用反射破坏单例的演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Constructor con = Singleton4<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;<span class="comment">//获取构造器</span></span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置私有为可访问</span></span><br><span class="line">        Singleton4 instance1 = (Singleton4) con.newInstance();</span><br><span class="line">        Singleton4 instance2 = (Singleton4) con.newInstance();</span><br><span class="line">        System.out.println(instance1.equals(instance2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式实现方式三：枚举</span></span><br><span class="line"><span class="comment"> * 成功解决反射破坏性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton5 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试反射是否可以破坏单例模式</span></span><br><span class="line"><span class="comment">//java.lang.NoSuchMethodException提示利用反射new示例不成功</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Constructor con = Singleton5<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;<span class="comment">//获取构造器</span></span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置私有为可访问</span></span><br><span class="line">        Singleton5 instance1 = (Singleton5) con.newInstance();</span><br><span class="line">        Singleton5 instance2 = (Singleton5) con.newInstance();</span><br><span class="line">        System.out.println(instance1.equals(instance2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu环境下执行sudo apt-get update出现无法获得锁 /var/lib/apt/lists/lock - open的问题解决方法</title>
    <url>/2019/05/15/%E4%B8%80%E7%9B%B4%E5%8D%A1%E5%9C%A8%200%25%5B%E6%AD%A3%E5%9C%A8%E7%AD%89%E5%BE%85%E6%8A%A5%E5%A4%B4%5D/</url>
    <content><![CDATA[<p>sudo rm -rf /var/lib/apt/lists/*  删除了该目录</p>
]]></content>
      <tags>
        <tag>问题解决</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口的最大值</title>
    <url>/2019/02/12/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!list.isEmpty() &amp;&amp; num[list.peekLast()] &lt; num[i])&#123;</span><br><span class="line">                list.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            list.offerLast(i);</span><br><span class="line">            <span class="keyword">if</span>(list.peekFirst() &lt;= i - size) list.pollFirst();</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= size - <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(num[list.peekFirst()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>双端队列</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的第k个节点</title>
    <url>/2019/02/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码."></a>代码.</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">      int val = 0;</span></span><br><span class="line"><span class="comment">      TreeNode left = null;</span></span><br><span class="line"><span class="comment">      TreeNode right = null;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">      public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">          this.val = val;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || pRoot != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(pRoot);</span><br><span class="line">                pRoot = pRoot.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                pRoot = stack.pop();</span><br><span class="line">                pRoot = pRoot.right; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>剪绳子</title>
    <url>/2019/02/05/%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i],Math.max(j*(i-j), j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化二叉树</title>
    <url>/2019/02/05/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = root.val + <span class="string">"!"</span>;</span><br><span class="line">        str += Serialize(root.left); </span><br><span class="line">        str += Serialize(root.right);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       String[] arr = str.split(<span class="string">"!"</span>);</span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            list.offer(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(list);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">dfs</span><span class="params">(LinkedList&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        String ch = list.poll();</span><br><span class="line">        <span class="keyword">if</span>(ch.equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(Integer.valueOf(ch));</span><br><span class="line">        head.left = dfs(list);</span><br><span class="line">        head.right = dfs(list);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>先序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>数据流的中位数</title>
    <url>/2019/02/05/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1,o2)-&gt;&#123;<span class="keyword">return</span> o2-o1;&#125;);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxHeap.isEmpty() || num &lt; maxHeap.peek())&#123;</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.size() - maxHeap.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxHeap.size() - minHeap.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.size() == maxHeap.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(minHeap.peek()+maxHeap.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> minHeap.size() &gt; maxHeap.size() ? (<span class="keyword">double</span>)minHeap.peek() : (<span class="keyword">double</span>)maxHeap.peek(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的路径</title>
    <url>/2019/02/05/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p>
<p>矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(matrix,rows,cols,str,i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; rows-<span class="number">1</span> || j &lt; <span class="number">0</span> || j &gt; cols-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = i*cols+j;</span><br><span class="line">        <span class="keyword">if</span>(k == str.length-<span class="number">1</span> &amp;&amp; matrix[index] == str[k])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(matrix[index] != <span class="string">'*'</span> &amp;&amp; matrix[index] == str[k])&#123;</span><br><span class="line">            <span class="keyword">char</span> t = matrix[index];</span><br><span class="line">            matrix[index] = <span class="string">'*'</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(matrix,rows,cols,str,i-<span class="number">1</span>,j,k+<span class="number">1</span>) || dfs(matrix,rows,cols,str,i+<span class="number">1</span>,j,k+<span class="number">1</span>)</span><br><span class="line">              || dfs(matrix,rows,cols,str,i,j-<span class="number">1</span>,k+<span class="number">1</span>) || dfs(matrix,rows,cols,str,i,j+<span class="number">1</span>,k+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            matrix[index] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者与消费者</title>
    <url>/2019/01/08/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文关于生产者和消费者问题，分为三个模块来阐述：使用Synchronized版本的<br>，使用Lock版本的，使用Condition实现精准唤醒。</p>
<h1 id="使用Synchronized版本"><a href="#使用Synchronized版本" class="headerlink" title="使用Synchronized版本"></a>使用Synchronized版本</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者和消费者问题 Synchronized 版</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"生产者"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"消费者"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者。当有资源时，就等待，直到资源为零，才开始启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -&gt; "</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我好了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者。当没有资源时，就等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -&gt; "</span> + number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>【问题】使用if判断存在虚假唤醒问题，如果不止两个线程的话，出现异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Data data &#x3D; new Data();</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;生产者&quot;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;生产者&quot;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;消费者&quot;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;消费者&quot;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>资源类代码还是不变，出现如下情况：生产者生成了一个资源之后，不是等到消费者去消耗完，而是继续生产很多个，这违背了生产者消费者原则。<br><img src="https://s1.ax1x.com/2020/04/02/GJj6v4.png" alt="avator"></p>
<p>官方文档建议wait方法必须始终在循环中执行，所以我们把它放在while循环中即可</p>
<p>资源类修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者。当有资源时，就等待，直到资源为零，才开始启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -&gt; "</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我好了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者。当没有资源时，就等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -&gt; "</span> + number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新执行：正常！！<br><img src="https://s1.ax1x.com/2020/04/02/GJjy2F.png" alt="avator"></p>
<h3 id="使用Lock版本"><a href="#使用Lock版本" class="headerlink" title="使用Lock版本"></a>使用Lock版本</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data2 data = <span class="keyword">new</span> Data2();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"D"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();<span class="comment">//监视器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Condiction实现精准唤醒"><a href="#使用Condiction实现精准唤醒" class="headerlink" title="使用Condiction实现精准唤醒"></a>使用Condiction实现精准唤醒</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Condition精准唤醒线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data3 data = <span class="keyword">new</span> Data3();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
</search>
