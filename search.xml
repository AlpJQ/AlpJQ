<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java内存模型JMM</title>
    <url>/2020/03/02/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</url>
    <content><![CDATA[<h2 id="原理初探"><a href="#原理初探" class="headerlink" title="原理初探"></a>原理初探</h2><p>在学习计算机组成原理的时候，我们都知道CPU的运行速度和内存不是一个级别的，CPU的速度非常快，为了缓解两者之间速度不一致的问题，我们在CPU和内存之间加了缓存。CPU执行过程中需要的数据，先从缓存中拿，如果命中了就直接拿，否则就从内存上读取，并放在缓存上面。<br>缓存分为一级缓存（L1 Cache），二级缓存（L2 Cache）和三级缓存（L3 Cache）。在多个缓存的情况下，为了保证这些缓存的数据一致，所以它们都必须遵守一些协议，常见的如MSI,MESI,MOSI等。<br>其中MESI保证每个缓存使用的共享变量的副本是一致的。核心思想：当CPU写数据时，如果发现操作的是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，则当其他CPU读取这个变量是，发现自己缓存中缓存该变量的缓存行是无效的，那么它就要从主内存中重新读取。</p>
<h2 id="JMM在同步的约定"><a href="#JMM在同步的约定" class="headerlink" title="JMM在同步的约定"></a>JMM在同步的约定</h2><ol>
<li>线程解锁前，必须把共享变量立刻刷回主存</li>
<li>线程加锁前，必须读取主存中的最新值到工作内存中</li>
<li>加锁和解锁是同一把锁</li>
</ol>
<p>【分析】下面JMM示意图中，工作内存就是每个线程自己的本地内存，每个线程优先访问工作内存，处理完之后再把工作内存向主内存进行刷新同步。</p>
<h4 id="工作内存和主内存之间有8种原子操作："><a href="#工作内存和主内存之间有8种原子操作：" class="headerlink" title="工作内存和主内存之间有8种原子操作："></a>工作内存和主内存之间有8种原子操作：</h4><p>read：在主内存中，读取变量到工作内存</p>
<p>load：在工作内存中，把read操作从主内存中读取的变量，放入到工作内存中的变量副本中</p>
<p>use：在工作内存中，把工作内存中的一个变量值传递给执行引擎，每当JVM遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p>
<p>assign：在工作内存中，把一个执行引擎接收到的值赋值给工作内存中的变量，每当JVM遇到一个给变量赋值的字节码指令时将会执行这个操作。</p>
<p>store：把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</p>
<p>write：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p>
<p>lock：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p>
<p>unlock：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
<p><img src="https://s1.ax1x.com/2020/03/23/8Tnl1U.png" alt="avator"></p>
<p>除此之外，Java内存模型还还规定了在执行上述8种基本操作时必须满足以下规则;</p>
<ul>
<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。<br>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>happens-before原则，它是判断数据是否存在竞争，线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作，准确来说是控制流程顺序，还要考虑分支和循环操作。</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作。</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li>
</ol>
<h3 id="volatile是Java虚拟提供的轻量级的同步机制"><a href="#volatile是Java虚拟提供的轻量级的同步机制" class="headerlink" title="volatile是Java虚拟提供的轻量级的同步机制"></a>volatile是Java虚拟提供的轻量级的同步机制</h3><p><strong>特性：</strong></p>
<ol>
<li>可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ol>
<h4 id="volatile读的内存语义："><a href="#volatile读的内存语义：" class="headerlink" title="volatile读的内存语义："></a>volatile读的内存语义：</h4><p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来姜葱主内存中读取共享变量。</p>
<h4 id="volatile写的内存语义："><a href="#volatile写的内存语义：" class="headerlink" title="volatile写的内存语义："></a>volatile写的内存语义：</h4><p>当写一个volatie变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>
<ol>
<li>可见性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.vl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMMDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不用volatile修饰的话，不能保证num的更新及时被其他线程发现，所以下面一个线程会一直在while中死循环</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出结果：程序正常结束！</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/23/8Tuubd.png" alt="avator"></p>
<ol start="2">
<li><p>不保证原子性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.vl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//num++；不是原子性擦操作</span></span><br><span class="line">        num.incrementAndGet(); <span class="comment">// AtomicInteger +1方法，底层是CAS</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">2</span>)&#123; <span class="comment">//main gc</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止指令重排<br>处理器在执行指令重排的时候，要考虑数据之间的依赖性。</p>
</li>
</ol>
<p>比如：定义某个变量的语句还未执行，而包含有这个变量的语句不能提前执行</p>
<p>volatile由于内存屏障，可以保证避免指令重排的现象发生。</p>
<blockquote>
<p>参考：《Java并发编程的艺术》，《深入理解Java虚拟机》</p>
</blockquote>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>第五篇</title>
    <url>/2020/03/02/JMM/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁CAS</title>
    <url>/2019/09/22/%E4%B9%90%E8%A7%82%E9%94%81CAS/</url>
    <content><![CDATA[<h3 id="乐观锁CAS"><a href="#乐观锁CAS" class="headerlink" title="乐观锁CAS"></a>乐观锁CAS</h3><p>下面的程序中我们可能会使用synchronized关键字来保证得到的num是正确的。但是这样会让没有得到锁的线程进入blocked状态，当拿到锁之后恢复到runnable状态，这个过程设计操作系统的用户模式和内核模式的切换。<br><br>Java从jdk1.5开始提供了<strong>java.util.concurrent.atomic</strong>包，这个包下有很多的原子类操作。例如常用的原子更新基本类型的<strong>AtomicBoolean，AtomicInteger，AtomicLong</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.jiasheng.CAS;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class TestCAS &#123;</span><br><span class="line">    private static AtomicInteger num &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public static void add() &#123;</span><br><span class="line">        &#x2F;&#x2F;num++；不是原子性擦操作，加上synchronized可以解决，但是严重降低了性能</span><br><span class="line">        num.incrementAndGet(); &#x2F;&#x2F; AtomicInteger +1方法，底层是CAS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 5000; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(Thread.activeCount() &gt; 2)&#123; &#x2F;&#x2F;main gc</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原子操作类的底层利用的正是CAS机制，全称即Compare and Swap。<br><br><br>先看一下compareAndSet源码：<br><br>调用这个方法传递的参数expect和update，expect期望值就是我们期望内存中某个变量的旧值是什么，update新值就是我们希望修改成什么值。valueOffset据说是一个偏移地址？不过不重要，这个不是重点，只要知道它是一个volatile修饰的变量即可。<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compareAndSet调用的compareAndSwapInt方法使用C++实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure>

<p>我们现在来看一下上面程序中++操作的incrementAndGet的源码：<br><br><strong>AtomicInteger.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Atomically increments by one the current value.</span><br><span class="line"> *</span><br><span class="line"> * @return the updated value</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delta就是需要自增的值，incrementAndGet传进来的是1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAdd(int delta) &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的unsafe类的getAndAddInt方法，继续查看这个方法的源码：<br><br><strong>unsafe.java</strong><br><br>这里var1是实例，var2就是偏移地址，var3就是上面的delta，这里是1<br><br>while循环中第三个参数var5就是expect值，var5+var4就是update值，var5这个值是根据this.getIntVolatile(var1, var2);计算出来的，就是读取到这个时刻内存这边旧值的最新值，因为有可能A线程准备替换之前，已经被B线程更新了，即两个线程都执行到了getIntVolatile方法。所以需要把var5更新到当前时刻的最新值。<br><br>while循坏就是判断就是except（也即var5）是否是线程A一开始希望的那个值，要确保是当前状态的最新值。</p>
<p><br>这里的while循环也叫作CAS自旋。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getAndAddInt方法里面调用的下面这两个方法都是native修饰的方法，即底层是C++实现的。效率会比自增操作高很多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int getIntVolatile(Object var1, long var2);</span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure>

<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ol>
<li>在高并发的场景下，如果多个线程都去反复尝试更新某一个相同的变量，但期望值却一直被改变了，就会造成循环次数很多，造成CPU很大的开销。</li>
<li>可能造成ABA问题。如果一个变量的值原来是A，先修改成B，然后又修改回A，使用CAS机制的话，无法分辨当前的except值是否已经发生过变化。</li>
</ol>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu环境下执行sudo apt-get update出现无法获得锁 /var/lib/apt/lists/lock - open的问题解决方法</title>
    <url>/2019/09/15/%E6%89%A7%E8%A1%8Csudo%20apt-get%20update%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/03/14/8QXxbt.png" alt="avator"></p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>执行ps -e | grep apt找到占用系统源更新时的系统锁的进程<br><img src="https://s1.ax1x.com/2020/03/14/8QjJq1.png" alt="avator"></li>
</ol>
<p>2.结束占用它的线程，输入命令sudo kill 进程ID号<br>再次执行 ps -e | grep apt，发现已经没有占用apt -get的进程了<br><img src="https://s1.ax1x.com/2020/03/14/8QjtVx.png" alt="avator"></p>
<ol start="3">
<li>输入sudo apt-get update，成功！</li>
</ol>
]]></content>
      <tags>
        <tag>问题解决</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是fail-fast？什么是fail-safe？</title>
    <url>/2019/09/15/%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFfail-safe%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是fail-fast？什么是fail-safe？"><a href="#什么是fail-fast？什么是fail-safe？" class="headerlink" title="什么是fail-fast？什么是fail-safe？"></a>什么是fail-fast？什么是fail-safe？</h1><h2 id="fail-fast快速失效机制。"><a href="#fail-fast快速失效机制。" class="headerlink" title="fail-fast快速失效机制。"></a>fail-fast快速失效机制。</h2><p>这是在Java集合框架中的一种机制。当多个线程对同一个集合的内容进行操作时（并发操作），就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>下面是ArrayLlist结合源码中，堆这种机制的解释。</p>
<p>除了iterator自己本身的方法，如remove和add对集合结构作出修改不会抛出异常，其它意图修改集合结构的行为，都会抛出ConcurrentModificationException。<br><img src="https://s1.ax1x.com/2020/04/06/GyGU1K.png" alt="avator"></p>
<p>迭代器的快速失败机制是没有保证的，也就是这种机制是尽自己的最大努力抛出ConcurrentModificationException异常。官方的建议是fast-fail最好用于检测bug中。<br><img src="https://s1.ax1x.com/2020/04/06/GyGNp6.png" alt="avator"></p>
<p>查看ArrayList中关于Iterator的部分源码：<br><br>可以看到next()等函数时都会先调用checkForComodification函数来检查modCount 和expectedModCount是否相等，如果不相等，则会抛出异常。<br><br>通过上面的remove函数（clear和sort等也会）的源码，我们知道modCount会++，所以如果在迭代器遍历元素的时候，修改了modeCount，也就是进行了remove操作，就会触发fail-fast机制抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h2><p>fail-safe很明显，就是一种安全机制，不会像fail-fast那样抛出ConcurrentModificationException异常。</p>
<p>原因：如果在遍历的过程中，集合的结构被修改了，那么触发fail-safe机制，会把原集合的复制一份，继续在复制后的集合中遍历。</p>
<p>缺点：复制会消耗额外的时间和空间开销，并且不能保证遍历的是最新的数据。<br><img src="https://s1.ax1x.com/2020/04/06/GyGJt1.png" alt="avator"></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出ABA问题</title>
    <url>/2019/09/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAABA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="什么是ABA问题？"><a href="#什么是ABA问题？" class="headerlink" title="什么是ABA问题？"></a>什么是ABA问题？</h3><p>如果一个变量的值原来是A，先修改成B，然后又修改回A，使用<strong>CAS机制</strong>的话，无法分辨当前的except值是否已经发生过变化。（可先理解一下什么是CAS机制）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.CAS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建两个线程</span></span><br><span class="line"><span class="comment"> * A线程需要把2改成3</span></span><br><span class="line"><span class="comment"> * B线程先把2改成6，再把6改回2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestABA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 开启，num = "</span> + atomicInteger);</span><br><span class="line">            <span class="comment">//A线程休眠2s，让出CPU给其他线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS操作一波</span></span><br><span class="line">            <span class="keyword">boolean</span> except = atomicInteger.compareAndSet(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">"cas is success ? "</span> + except);</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//保证main线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicInteger.incrementAndGet();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"increment, num = "</span> + atomicInteger);</span><br><span class="line"></span><br><span class="line">            atomicInteger.decrementAndGet();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"decrement, num = "</span> + atomicInteger);</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/22/8oQT9P.png" alt="avator"></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以给竞争资源加锁，但是这样性能会降低。所以，我们使用<strong>AtomicStampedReference</strong>类。这是一个原子更新带有<strong>版本号</strong>的引用类型，每次操作都会更改版本号。</p>
<p><strong>构造函数</strong><br>initialRef初始值，initialStamp初始版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public AtomicStampedReference(V initialRef, int initialStamp) &#123;</span><br><span class="line">    pair &#x3D; Pair.of(initialRef, initialStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getReference方法</strong><br><br>作用：返回当前版本号下的变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns the current value of the reference.</span><br><span class="line"> *</span><br><span class="line"> * @return the current value of the reference</span><br><span class="line"> *&#x2F;</span><br><span class="line">public V getReference() &#123;</span><br><span class="line">    return pair.reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getStamp方法</strong><br><br>作用：返回变量当前值的版本号，即获取最新的版本号是多少</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns the current value of the stamp.</span><br><span class="line"> *</span><br><span class="line"> * @return the current value of the stamp</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int getStamp() &#123;</span><br><span class="line">    return pair.stamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>compareAndSet方法</strong><br><br>expectedReference：旧的值<br><br>newReference：新的值，就是我们想要修改为什么值<br><br>expectedStamp：旧的版本号<br><br>newStamp：新的版本号，一般是expectedStamp+1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   newReference,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int newStamp) &#123;</span><br><span class="line">    Pair&lt;V&gt; current &#x3D; pair;</span><br><span class="line">    return</span><br><span class="line">        expectedReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">        expectedStamp &#x3D;&#x3D; current.stamp &amp;&amp;</span><br><span class="line">        ((newReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">          newStamp &#x3D;&#x3D; current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改上述存在ABA问题的程序"><a href="#修改上述存在ABA问题的程序" class="headerlink" title="修改上述存在ABA问题的程序"></a>修改上述存在ABA问题的程序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.CAS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolveABA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 开启，num = "</span> + stampedReference.getReference());</span><br><span class="line">            <span class="comment">//当前标识</span></span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            <span class="comment">//A线程休眠2s，让出CPU给其他线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS操作一波</span></span><br><span class="line">            <span class="keyword">boolean</span> except = stampedReference.compareAndSet(<span class="number">2</span>, <span class="number">3</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"cas is success ? "</span> + except);</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//保证main线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">2</span>, <span class="number">6</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"increment, num = "</span> + stampedReference.getReference());</span><br><span class="line"></span><br><span class="line">            stampedReference.compareAndSet(<span class="number">6</span>, <span class="number">2</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"decrement, num = "</span> + stampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong><br><img src="https://s1.ax1x.com/2020/03/22/8oQ4AA.png" alt="avator"></p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis快速入门</title>
    <url>/2019/08/12/Mybatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><ul>
<li>列表1</li>
<li>列表2<br>  快速入门系列</li>
</ul>
<p>1、简介</p>
<p>1.1、什么是MyBatis<br>简介<br>什么是 MyBatis？<br>MyBatis 是一款优秀的持久层框架<br>它支持定制化 SQL、存储过程以及高级映射。<br>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。<br>如何获得MyBatis？<br>Maven仓库</p>
]]></content>
      <tags>
        <tag>框架</tag>
        <tag>Mybatis</tag>
        <tag>Java</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>算法1</title>
    <url>/2019/08/09/Thread%E6%8A%80%E6%9C%AF%E7%82%B9/</url>
    <content><![CDATA[<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>Thread类实现Runnable接口，继承自Objeact类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Thread</span><br><span class="line">extends Object</span><br><span class="line">implements Runnable</span><br></pre></td></tr></table></figure>

<p>start() 方法，使该线程开始执行，Java虚拟机调用该线程的run方法。调用该方法之后线程就会进入就绪状态，不是一定会成为运行状态！！</p>
<p>stop() 方法，调用该方法强制结束该线程结束</p>
<p>sleep() 方法，调用该方法该线程进入等待状态</p>
<p>run() 方法，调用该方法直接执行线程的run方法。和start方法不同的是，start方法是让线程调度执行run方法。</p>
<h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><p>sleep方法底层是native修饰的c++编写的方法。</p>
<p>在源码中的说明是，当线程执行此方法时，并不会失去对monitor的掌握权。即只会会当前线程睡眠一会。</p>
<p>Thead.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;The thread does not lose ownership of any monitors.</span><br><span class="line">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure>

<p>Object.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>

<p>【细节】一般使用sleep使用的是java.util.concurrent包下TimeUnit类的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TimeUnit.SECONDS.sleep(2);</span><br></pre></td></tr></table></figure>

<p>1.wait是Object类的方法，sleep是Thead类的方法</p>
<p>2.wait会释放锁，所以只能在synchronized方法或synchronized块中使用；sleep不会释放锁，可以在任何地方使用</p>
<p><strong>最主要的本质区别:</strong></p>
<p>Thread.sleep只会让出CPU,不会导致锁行为的改变</p>
<p>Object.wait不仅让出CPU，还会释放已经占有的同步资源锁</p>
<h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>yield只是简单地对CPU时间片的礼让，除非循环yield，否则一次yield可能下次该线程仍旧可能会抢占到CPU时间片。</p>
<h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>底层还是wait方法</p>
<p>哪个线程调用x.join()，哪个线程（下面例子就是main线程）就挂起。并且join要start调用之后。</p>
<p>Join()方法，使调用此方法的线程wait()（在例子中是main线程）,直到调用此方法的线程对象（在例子中是thread1对象）所在的线程（在例子中是子线程）执行完毕后被唤醒。</p>
<p>比如主线程main中调用启动线程（调用start），然后调用该线程的join方法，可以达到主线程等待工作线程运行结束之后才执行的效果，并且join要在start调用后。</p>
<p>【示例】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread thread1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程1正在执行-----&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   thread1.start();</span><br><span class="line">   thread1.join();</span><br><span class="line">   System.out.println(&quot;main线程&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">main线程</span><br></pre></td></tr></table></figure>

<p>【注意】如果start在join之后，就不能保证main线程需要等待thread1运行结束之后才运行了。如上面的例子修改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread1.join();</span><br><span class="line">thread1.start();</span><br><span class="line">System.out.println(&quot;main线程&quot;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main线程</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br><span class="line">线程1正在执行-----</span><br></pre></td></tr></table></figure>

<p>【源码分析】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    long base &#x3D; System.currentTimeMillis();</span><br><span class="line">    long now &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            long delay &#x3D; millis - now;</span><br><span class="line">            if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>算法2</title>
    <url>/2019/08/02/%E8%AF%BB%E5%86%99%E9%94%81/</url>
    <content><![CDATA[<p>ReadWriteLock接口  </p>
<p>&emsp;&emsp;排他锁（如ReentratLock等），也叫互斥锁，在同一时刻只允许一个线程进行访问，而读写锁在同一个时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他线程均被阻塞。  </p>
<p>&emsp;&emsp;与互斥锁相比，读-写锁允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer 线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程），读-写锁利用了这一点。从理论上讲，与互斥锁相比，使用读-写锁所允许的并发性增强将带来更大的性能提高。在实践中，只有在多处理器上并且只在访问模式适用于共享数据时，才能完全实现并发性增强。  </p>
<p>&emsp;&emsp;不是所有情况都是读写锁并发性能更好的：与互斥锁相比，使用读-写锁能否提升性能则取决于读写操作期间读取数据相对于修改数据的频率，以及数据的争用——即在同一时间试图对该数据执行读取或写入操作的线程数。例如，某个最初用数据填充并且之后不经常对其进行修改的 collection，因为经常对其进行搜索（比如搜索某种目录），所以这样的 collection 是使用读-写锁的理想候选者。但是，如果数据更新变得频繁，数据在大部分时间都被独占锁，这时，就算存在并发性增强，也是微不足道的。更进一步地说，如果读取操作所用时间太短，则读-写锁实现（它本身就比互斥锁复杂）的开销将成为主要的执行成本，在许多读-写锁实现仍然通过一小段代码将所有线程序列化时更是如此。最终，只有通过分析和测量，才能确定应用程序是否适合使用读-写锁。</p>
<p>实现类ReentrantReadWriteLock</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>五段程序带你深刻理解单例模式</title>
    <url>/2019/08/02/%E4%BA%94%E6%AE%B5%E7%A8%8B%E5%BA%8F%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="五段程序带你深刻理解单例模式"><a href="#五段程序带你深刻理解单例模式" class="headerlink" title="五段程序带你深刻理解单例模式"></a>五段程序带你深刻理解单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式就是让一个类只能构建一个对象的设计模式</span></span><br><span class="line"><span class="comment"> * 此程序主要用于演示懒汉式和饿汉式</span></span><br><span class="line"><span class="comment"> *      饿汉式：在构造器之前就已经主动创建好实例。</span></span><br><span class="line"><span class="comment"> *      懒汉式：延迟实例化，等构造器来创建实例。</span></span><br><span class="line"><span class="comment"> * 问题：线程安全有隐患。</span></span><br><span class="line"><span class="comment"> *  如果多个线程同时调用getInstance方法，刚好都通过了判空的操作，开始执行new操作</span></span><br><span class="line"><span class="comment"> *  就会造成new重复多次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用静态变量来记录Singleton类的唯一实例</span></span><br><span class="line"><span class="comment">     * 它的初始值可以写成null，也可以写成new Singleton()</span></span><br><span class="line"><span class="comment">     * 分别可能造成懒汉式和饿汉式问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要让一个类只能构建一个对象，自然不能让它随便去做new操作，</span></span><br><span class="line"><span class="comment">     * 只有Hungry类里面才可以调用构造方法，因此Hungry的构造方法</span></span><br><span class="line"><span class="comment">     * 是私有的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂方法,获取单例对象。</span></span><br><span class="line"><span class="comment">     * 如果单例初始值instance是null，还未构建，则构建对象并返回。这种方式就是懒汉式,即延迟实例化。</span></span><br><span class="line"><span class="comment">     * 如果单例初始值一开始就通过new Singleton()主动创建，则不再需要判空操作。这种方式就是饿汉式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式</span></span><br><span class="line"><span class="comment"> * 破除第一版的线程安全问题</span></span><br><span class="line"><span class="comment"> * 方法一：在创建实例的方法加上synchronized，迫使每个线程在进入这个方法之前，要先等待其他线程</span></span><br><span class="line"><span class="comment"> *        离开该方法，也就是说，不会有两个线程同时进入这个方法，保证了线程安全。</span></span><br><span class="line"><span class="comment"> * 问题：严重影响性能！原因：只有第一次执行此方法，才真正需要同步，此后每次调用这个方法都是一种累赘</span></span><br><span class="line"><span class="comment"> * 同步一个方法可能造成程序执行效率下降100倍</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 方法二 ：DCL = double check lock  -&gt; 双重检测机制</span></span><br><span class="line"><span class="comment"> * 问题：存在指令重排问题（见下一个程序）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static synchronized Singleton2 getInstance()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一个if判断：只有当instance为null，才会向同步方法走去。如果没有这个if判断，则每次调用这个</span></span><br><span class="line"><span class="comment">     * getInstance方法，都会进入synchronized同步区，性能严重下降</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第二个if判断：假如有多个线程在同步方法入口那里，这时只能有一个线程（假设为A线程）可以进入</span></span><br><span class="line"><span class="comment">     * 同步代码块，如果是第一次进入，A线程在第二个if判断处判断为null，就会new Singleton2()。接着A线程</span></span><br><span class="line"><span class="comment">     * 退出synchronized区，此后即使有已经在synchronized处等待的线程进入同步代码块，还是会在第二个if判断处</span></span><br><span class="line"><span class="comment">     * 判定不为null，也就不会创建第二个instance。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式实现方式一：双重加锁机制+volatile</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * new Singleton3()在多线程环境下存在指令重排问题</span></span><br><span class="line"><span class="comment"> * new Singleton3()会被编译器编程成如下的JVM指令：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * memory = allocate();  //1.分配对象的内存空间</span></span><br><span class="line"><span class="comment"> * ctorInstance(memory); //2.初始化对象</span></span><br><span class="line"><span class="comment"> * instance = memory;    //3.设置instance指向刚才分配的内存空间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这些指令顺序并不是一成不变的，有可能经过JVM和CPU的优化，指令重排为1 3 2</span></span><br><span class="line"><span class="comment"> * 当A线程执行完指令1,3之后，instance还未完成初始化工作，但是已经不再指向null</span></span><br><span class="line"><span class="comment"> * 此时B线程进来第一个if判断instance为null，就直接return instance;了，这样子</span></span><br><span class="line"><span class="comment"> * 返回的instance是空的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解决：使用volatile禁止指令重排</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 存在问题：可以通过反射new多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式实现方式二：静态内部类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 存在问题：可以通过反射new多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类，外部无法访问，只有当调用Singleton4.getInstance()方法时，才能</span></span><br><span class="line"><span class="comment">     * 得到单例对象。</span></span><br><span class="line"><span class="comment">     * 【注意】单例对象instance初始化的时机并不是在单例类Singleton4被加载的时候，</span></span><br><span class="line"><span class="comment">     * 而是在调用getInstance()方法，使得静态内部类LazyHolder被加载的时候。</span></span><br><span class="line"><span class="comment">     * 因此，这种实现方式是利用ClassLoader的加载机制来实现懒加载的，并保证构建单例的线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton4 instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> LazyHolder.instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用反射破坏单例的演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Constructor con = Singleton4<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;<span class="comment">//获取构造器</span></span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置私有为可访问</span></span><br><span class="line">        Singleton4 instance1 = (Singleton4) con.newInstance();</span><br><span class="line">        Singleton4 instance2 = (Singleton4) con.newInstance();</span><br><span class="line">        System.out.println(instance1.equals(instance2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiasheng.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式实现方式三：枚举</span></span><br><span class="line"><span class="comment"> * 成功解决反射破坏性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton5 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试反射是否可以破坏单例模式</span></span><br><span class="line"><span class="comment">//java.lang.NoSuchMethodException提示利用反射new示例不成功</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Constructor con = Singleton5<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;<span class="comment">//获取构造器</span></span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置私有为可访问</span></span><br><span class="line">        Singleton5 instance1 = (Singleton5) con.newInstance();</span><br><span class="line">        Singleton5 instance2 = (Singleton5) con.newInstance();</span><br><span class="line">        System.out.println(instance1.equals(instance2));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu环境下执行sudo apt-get update出现无法获得锁 /var/lib/apt/lists/lock - open的问题解决方法</title>
    <url>/2019/05/15/%E4%B8%80%E7%9B%B4%E5%8D%A1%E5%9C%A8%200%25%5B%E6%AD%A3%E5%9C%A8%E7%AD%89%E5%BE%85%E6%8A%A5%E5%A4%B4%5D/</url>
    <content><![CDATA[<p>sudo rm -rf /var/lib/apt/lists/*  删除了该目录</p>
]]></content>
      <tags>
        <tag>问题解决</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>算法4</title>
    <url>/2019/02/12/%E7%AE%97%E6%B3%954/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法3</title>
    <url>/2019/02/05/%E7%AE%97%E6%B3%953/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者与消费者</title>
    <url>/2019/01/08/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文关于生产者和消费者问题，分为三个模块来阐述：使用Synchronized版本的<br>，使用Lock版本的，使用Condition实现精准唤醒。</p>
<h1 id="使用Synchronized版本"><a href="#使用Synchronized版本" class="headerlink" title="使用Synchronized版本"></a>使用Synchronized版本</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者和消费者问题 Synchronized 版</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"生产者"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"消费者"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者。当有资源时，就等待，直到资源为零，才开始启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -&gt; "</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我好了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者。当没有资源时，就等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -&gt; "</span> + number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line">生产者 -&gt; 1</span><br><span class="line">消费者 -&gt; 0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>【问题】使用if判断存在虚假唤醒问题，如果不止两个线程的话，出现异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Data data &#x3D; new Data();</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;生产者&quot;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;生产者&quot;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;消费者&quot;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;消费者&quot;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>资源类代码还是不变，出现如下情况：生产者生成了一个资源之后，不是等到消费者去消耗完，而是继续生产很多个，这违背了生产者消费者原则。<br><img src="https://s1.ax1x.com/2020/04/02/GJj6v4.png" alt="avator"></p>
<p>官方文档建议wait方法必须始终在循环中执行，所以我们把它放在while循环中即可</p>
<p>资源类修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者。当有资源时，就等待，直到资源为零，才开始启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -&gt; "</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我好了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者。当没有资源时，就等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -&gt; "</span> + number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新执行：正常！！<br><img src="https://s1.ax1x.com/2020/04/02/GJjy2F.png" alt="avator"></p>
<h3 id="使用Lock版本"><a href="#使用Lock版本" class="headerlink" title="使用Lock版本"></a>使用Lock版本</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data2 data = <span class="keyword">new</span> Data2();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"D"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();<span class="comment">//监视器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Condiction实现精准唤醒"><a href="#使用Condiction实现精准唤醒" class="headerlink" title="使用Condiction实现精准唤醒"></a>使用Condiction实现精准唤醒</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Condition精准唤醒线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data3 data = <span class="keyword">new</span> Data3();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
</search>
